{"version":3,"sources":["excalidraw/src/math.ts","excalidraw/src/utils.ts","excalidraw/src/element/bounds.ts","excalidraw/src/element/sizeHelpers.ts","excalidraw/src/element/newElement.ts","excalidraw/src/element/handlerRectangles.ts","excalidraw/src/element/collision.ts","excalidraw/src/element/index.ts","excalidraw/src/keys.ts","excalidraw/src/constants.ts","excalidraw/src/element/mutateElement.ts","excalidraw/src/element/typeChecks.ts","excalidraw/src/i18n.ts","excalidraw/src/scene/zoom.ts","excalidraw/src/scene/globalScene.ts","excalidraw/src/renderer/renderElement.ts","excalidraw/src/random.ts","excalidraw/src/scene/selection.ts","excalidraw/src/points.ts","excalidraw/src/scene/scroll.ts","excalidraw/src/scene/scrollbars.ts","excalidraw/src/groups.ts","excalidraw/src/locales lazy /^/.//.*$/ groupOptions: {} namespace object","Viewer.tsx","viewer.worker.ts","excalidraw/src/appState.ts","excalidraw/src/data/restore.ts","excalidraw/src/data/blob.ts","excalidraw/src/data/json.ts","Toolbar.tsx","excalidraw/src/colors.ts","excalidraw/src/element/linearElementEditor.ts","excalidraw/src/clipboard.ts","excalidraw/src/data/index.ts","App.tsx","useLoadElements.ts","serviceWorker.ts","index.tsx"],"names":["distanceBetweenPointAndSegment","x","y","x1","y1","x2","y2","xx","yy","C","D","lenSquare","param","dx","dy","Math","hypot","rotate","angle","cos","sin","adjustXYWithRotation","sides","deltaX1","deltaY1","deltaX2","deltaY2","e","w","n","s","getFlipAdjustment","side","nextWidth","nextHeight","nextX1","nextY1","nextX2","nextY2","finalX1","finalY1","finalX2","finalY2","needsRotation","flipDiffX","flipDiffY","distance2d","xd","yd","isPathALoop","points","length","firstPoint","lastPoint","LINE_CONFIRM_THRESHOLD","isPointInPolygon","vertices","extreme","Number","MAX_SAFE_INTEGER","p","count","i","current","next","doIntersect","orientation","onSegment","q","r","max","min","val","p1","q1","p2","q2","o1","o2","o3","o4","SVG_NS","mockDateTime","getDateTime","date","Date","year","getFullYear","month","getMonth","padStart","day","getDate","hr","getHours","getMinutes","isWritableElement","target","HTMLElement","dataset","type","HTMLBRElement","HTMLTextAreaElement","HTMLInputElement","getFontFamilyString","fontFamily","FONT_FAMILY","getFontString","fontSize","measureText","text","font","line","document","createElement","body","style","position","whiteSpace","appendChild","innerText","split","map","join","width","offsetWidth","height","offsetHeight","span","display","overflow","baseline","offsetTop","removeChild","distance","abs","viewportCoordsToSceneCoords","canvas","scale","clientX","clientY","scrollX","scrollY","zoom","zoomOrigin","getZoomOrigin","sceneCoordsToViewportCoords","sceneX","sceneY","getGlobalCSSVariable","name","getComputedStyle","documentElement","getPropertyValue","RE_RTL_CHECK","RegExp","isRTL","test","getElementAbsoluteCoords","element","isLinearElement","getLinearElementAbsoluteCoords","getDiamondPoints","topX","floor","rightX","rightY","getCurvePathOps","shape","sets","set","ops","getMinMaxXYFromCurvePathOps","transformXY","currentP","reduce","limits","op","data","p3","p0","equation","t","idx","pow","minY","minX","maxX","maxY","Infinity","getShapeForElement","getArrowPoints","prevOp","nx","ny","arrowLength","total","cx","cy","px","py","minSize","xs","ys","PI","x3","y3","getElementBounds","getLinearElementRotatedBounds","x11","y11","x12","y12","x22","y22","x21","y21","h","ww","hh","getCommonBounds","elements","forEach","getResizedElementAbsoluteCoords","rescalePoints","curve","rough","generator","generateRoughOptions","getElementPointsCoords","getClosestElementBounds","from","minDistance","closestElement","isInvisiblySmallElement","getNormalizedDimensions","ret","_newElementBase","strokeColor","backgroundColor","fillStyle","strokeWidth","strokeStyle","roughness","opacity","groupIds","rest","id","randomId","seed","randomInteger","version","versionNonce","isDeleted","newElement","opts","getTextElementPositionOffsets","metrics","textAlign","verticalAlign","newTextElement","offsets","newElementWith","handleSizes","mouse","pen","touch","OMIT_SIDES_FOR_MULTIPLE_ELEMENTS","rotation","OMIT_SIDES_FOR_TEXT_ELEMENT","OMIT_SIDES_FOR_LINE_SLASH","nw","se","OMIT_SIDES_FOR_LINE_BACKSLASH","ne","sw","generateHandler","handlerRectanglesFromCoords","pointerType","omitSides","size","handlerWidth","handlerHeight","handlerMarginX","handlerMarginY","dashedLineMargin","centeringOffset","handlers","undefined","minimumSizeForEightHandlers","handlerRectangles","isElementDraggableFromInside","appState","dragFromInside","selectedElementIds","hitTest","lineThreshold","tx","ty","a","b","ex","ey","rx","ry","qx","qy","topY","bottomX","bottomY","leftX","leftY","relX","relY","some","subshape","hitTestCurveInside","hitTestRoughShape","console","warn","Error","drawable","operation","push","polygonPoints","pointsOnBezierCurves","mx","my","sqrt","pointInBezierEquation","getElementMap","window","navigator","platform","acc","getNonDeletedElements","filter","isNonDeletedElement","SCENE","EVENT","SHIFT_LOCKING_ANGLE","CURSOR_TYPE","TEXT","CROSSHAIR","GRABBING","POINTER","CLASSES","SHAPE_ACTIONS_MENU","1","2","3","DEFAULT_FONT_SIZE","DEFAULT_FONT_FAMILY","DEFAULT_TEXT_ALIGN","DEFAULT_VERTICAL_ALIGN","mutateElement","updates","didChange","key","getSizeFromPoints","value","prevPoints","nextPoints","didChangePoints","prevPoint","nextPoint","invalidateShapeForElement","globalSceneState","informMutation","isTextElement","languages","lng","label","concat","rtl","sort","left","right","lang","percentages","currentLanguage","currentLanguageData","getLanguage","findPartsForData","parts","part","path","replacement","translation","fallbackLanguageData","replace","languageDetector","LanguageDetector","init","languageUtils","formatLanguageCode","isWhitelisted","checkWhitelist","getContext","callbacks","Set","nonDeletedElements","elementsMap","this","getElement","nextElements","Array","callback","cb","has","add","delete","DASHARRAY_DASHED","DASHARRAY_DOTTED","drawElementOnCanvas","rc","context","globalAlpha","draw","shouldTemporarilyAttach","isConnected","setAttribute","lines","lineHeight","verticalOffset","horizontalOffset","fillText","remove","elementWithCanvasCache","WeakMap","shapeCache","get","options","strokeLineDash","disableMultiStroke","fillWeight","hachureGap","stroke","fill","curveFitting","generateElementShape","rectangle","polygon","ellipse","x4","y4","generateElementWithCanvas","sceneState","prevElementWithCanvas","shouldRegenerateBecauseZoom","canvasZoom","shouldCacheIgnoreZoom","elementWithCanvas","canvasOffsetX","canvasOffsetY","devicePixelRatio","CANVAS_PADDING","translate","generateElementCanvas","renderElement","renderOptimizations","fillRect","drawImage","drawElementFromCanvas","shiftX","shiftY","renderElementToSvg","rsvg","svgRoot","offsetX","offsetY","degree","node","group","ownerDocument","createElementNS","direction","textAnchor","textContent","random","Random","now","nanoid","getSelectedElements","point","dimension","nextDimensionSize","prevDimValues","prevMaxDimension","prevMinDimension","prevDimensionSize","dimensionScaleFactor","nextMinDimension","scaledPoints","currentDimension","scaledValue","scaledPoint","normalizeScroll","pos","calculateScrollCenter","cords","viewportX1","viewportY1","viewportX2","viewportY2","innerWidth","innerHeight","isOutsideViewPort","centerX","centerY","SCROLLBAR_WIDTH","SCROLLBAR_COLOR","getScrollBars","viewportWidth","viewportHeight","elementsMinX","elementsMinY","elementsMaxX","elementsMaxY","viewportWidthWithZoom","viewportHeightWithZoom","viewportWidthDiff","viewportHeightDiff","safeArea","top","parseInt","bottom","viewportMinX","viewportMinY","viewportMaxX","viewportMaxY","sceneMinX","sceneMinY","sceneMaxX","sceneMaxY","horizontal","SCROLLBAR_MARGIN","vertical","isSelectedViaGroup","groupId","editingGroupId","find","selectedGroupIds","getSelectedGroupIds","Object","entries","getElementsInGroup","includes","isElementInGroup","getNewGroupIdsForDuplication","mapper","copy","positionOfEditingGroupId","indexOf","endIndex","webpackAsyncContext","req","__webpack_require__","o","Promise","resolve","then","code","ids","all","slice","keys","module","exports","Viewer","canvasRef","useRef","useEffect","parentElement","clientWidth","clientHeight","worker","Worker","offscreen","transferControlToOffscreen","postMessage","viewAngle","onWheel","preventDefault","ctrlKey","deltaY","shiftKey","deltaX","addEventListener","passive","terminate","removeEventListener","className","ref","getDefaultAppState","isLoading","errorMessage","draggingElement","resizingElement","multiElement","editingElement","editingLinearElement","elementType","elementLocked","exportBackground","shouldAddWatermark","currentItemStrokeColor","oc","black","currentItemBackgroundColor","currentItemFillStyle","currentItemStrokeWidth","currentItemStrokeStyle","currentItemRoughness","currentItemOpacity","currentItemFontSize","currentItemFontFamily","currentItemTextAlign","viewBackgroundColor","white","cursorX","cursorY","cursorButton","scrolledOutside","username","isCollaborating","isResizing","isRotating","selectionElement","openMenu","lastPointerDownWith","previousSelectedElementIds","collaborators","Map","showShortcutsDialog","zenModeEnabled","gridSize","migrateElementWithProperties","extra","base","migrateElement","fontPx","_fontFamily","fontFamilyName","getFontFamilyByName","isArray","restore","savedElements","savedState","migratedElement","scrollToContent","loadFromBlob","blob","updateAppState","contents","defaultAppState","JSON","parse","handle","Blob","reader","FileReader","readAsText","onloadend","readyState","DONE","result","loadFromJSON","fileOpen","description","extensions","mimeTypes","linkRegex","Toolbar","loadData","useState","showToolbar","setShowToolbar","link","setLink","hash","location","URLSearchParams","loadFile","onClick","disabled","onSubmit","event","match","exec","reload","alert","placeholder","onChange","shades","red","pink","grape","violet","indigo","blue","cyan","teal","green","lime","yellow","orange","gray","LinearElementEditor","elementId","activePointIndex","draggingElementPointIndex","lastUncommittedPoint","normalizePoints","getNonDeletedElement","setState","scenePointerX","scenePointerY","lastX","lastY","clickedPointIndex","getPointIndexUnderCursor","targetPoint","movePoint","history","didAddPoint","hitElement","altKey","createPointAt","resumeRecording","newPoint","pointHandles","getPointsGlobalCoordinates","POINT_HANDLE_SIZE","rotatedX","rotatedY","_idx","pointIndex","targetPosition","splice","nextCoords","prevCoords","nextCenterX","nextCenterY","dX","dY","rotated","clipboard","HTMLCanvasElement","prototype","getImportedKey","usage","crypto","subtle","importKey","alg","ext","k","key_ops","kty","importFromBackend","privateKey","fetch","process","response","ok","arrayBuffer","buffer","iv","Uint8Array","decrypt","decrypted","string","TextDecoder","decode","json","error","App","loading","setLoading","setElements","useCallback","searchParams","useLoadElements","Boolean","hostname","ReactDOM","render","StrictMode","getElementById","serviceWorker","ready","registration","unregister","catch","message"],"mappings":"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X,EAAQsF,SAAS8S,SAASR,GAOGS,CAAiBrY,EAAS4X,MAUzD,SAASU,EACdhT,EACAuS,EACAU,GAQA,IANA,IAAMC,EAAI,YAAOlT,GACXmT,EAA2BZ,EAC7BvS,EAASoT,QAAQb,IAChB,EACCc,EACJF,GAA4B,EAAIA,EAA2BnT,EAASlM,OAC7DW,EAAI,EAAGA,EAAI4e,EAAU5e,IAC5Bye,EAAKze,GAAKwe,EAAOC,EAAKze,IAGxB,OAAOye,I,skNCzHT,IAAI7a,EAAM,CACT,cAAe,CACd,GACA,EACA,IAED,UAAW,CACV,GACA,EACA,GAED,eAAgB,CACf,GACA,EACA,GAED,UAAW,CACV,GACA,EACA,GAED,eAAgB,CACf,GACA,EACA,GAED,UAAW,CACV,GACA,EACA,GAED,eAAgB,CACf,GACA,EACA,GAED,UAAW,CACV,GACA,EACA,GAED,eAAgB,CACf,GACA,EACA,GAED,UAAW,CACV,GACA,EACA,GAED,eAAgB,CACf,GACA,EACA,GAED,OAAQ,CACP,GACA,GAED,YAAa,CACZ,GACA,GAED,UAAW,CACV,GACA,EACA,GAED,eAAgB,CACf,GACA,EACA,GAED,UAAW,CACV,GACA,EACA,GAED,eAAgB,CACf,GACA,EACA,GAED,UAAW,CACV,GACA,EACA,GAED,eAAgB,CACf,GACA,EACA,GAED,UAAW,CACV,GACA,EACA,GAED,eAAgB,CACf,GACA,EACA,GAED,UAAW,CACV,GACA,EACA,GAED,eAAgB,CACf,GACA,EACA,GAED,UAAW,CACV,GACA,EACA,IAED,eAAgB,CACf,GACA,EACA,IAED,UAAW,CACV,GACA,EACA,IAED,eAAgB,CACf,GACA,EACA,IAED,UAAW,CACV,GACA,EACA,IAED,eAAgB,CACf,GACA,EACA,IAED,UAAW,CACV,GACA,EACA,IAED,eAAgB,CACf,GACA,EACA,IAED,UAAW,CACV,GACA,EACA,IAED,eAAgB,CACf,GACA,EACA,IAED,UAAW,CACV,GACA,EACA,IAED,eAAgB,CACf,GACA,EACA,IAED,UAAW,CACV,GACA,EACA,IAED,eAAg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","file":"static/js/main.fa829f9c.chunk.js","sourcesContent":["import { Point } from \"./types\";\nimport { LINE_CONFIRM_THRESHOLD } from \"./constants\";\nimport { ExcalidrawLinearElement } from \"./element/types\";\n\n// https://stackoverflow.com/a/6853926/232122\nexport const distanceBetweenPointAndSegment = (\n  x: number,\n  y: number,\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n) => {\n  const A = x - x1;\n  const B = y - y1;\n  const C = x2 - x1;\n  const D = y2 - y1;\n\n  const dot = A * C + B * D;\n  const lenSquare = C * C + D * D;\n  let param = -1;\n  if (lenSquare !== 0) {\n    // in case of 0 length line\n    param = dot / lenSquare;\n  }\n\n  let xx, yy;\n  if (param < 0) {\n    xx = x1;\n    yy = y1;\n  } else if (param > 1) {\n    xx = x2;\n    yy = y2;\n  } else {\n    xx = x1 + param * C;\n    yy = y1 + param * D;\n  }\n\n  const dx = x - xx;\n  const dy = y - yy;\n  return Math.hypot(dx, dy);\n};\n\nexport const rotate = (\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  angle: number,\n): [number, number] =>\n  // 𝑎′𝑥=(𝑎𝑥−𝑐𝑥)cos𝜃−(𝑎𝑦−𝑐𝑦)sin𝜃+𝑐𝑥\n  // 𝑎′𝑦=(𝑎𝑥−𝑐𝑥)sin𝜃+(𝑎𝑦−𝑐𝑦)cos𝜃+𝑐𝑦.\n  // https://math.stackexchange.com/questions/2204520/how-do-i-rotate-a-line-segment-in-a-specific-point-on-the-line\n  [\n    (x1 - x2) * Math.cos(angle) - (y1 - y2) * Math.sin(angle) + x2,\n    (x1 - x2) * Math.sin(angle) + (y1 - y2) * Math.cos(angle) + y2,\n  ];\n\nexport const adjustXYWithRotation = (\n  sides: {\n    n?: boolean;\n    e?: boolean;\n    s?: boolean;\n    w?: boolean;\n  },\n  x: number,\n  y: number,\n  angle: number,\n  deltaX1: number,\n  deltaY1: number,\n  deltaX2: number,\n  deltaY2: number,\n): [number, number] => {\n  const cos = Math.cos(angle);\n  const sin = Math.sin(angle);\n  if (sides.e && sides.w) {\n    x += deltaX1 + deltaX2;\n  } else if (sides.e) {\n    x += deltaX1 * (1 + cos);\n    y += deltaX1 * sin;\n    x += deltaX2 * (1 - cos);\n    y += deltaX2 * -sin;\n  } else if (sides.w) {\n    x += deltaX1 * (1 - cos);\n    y += deltaX1 * -sin;\n    x += deltaX2 * (1 + cos);\n    y += deltaX2 * sin;\n  }\n\n  if (sides.n && sides.s) {\n    y += deltaY1 + deltaY2;\n  } else if (sides.n) {\n    x += deltaY1 * sin;\n    y += deltaY1 * (1 - cos);\n    x += deltaY2 * -sin;\n    y += deltaY2 * (1 + cos);\n  } else if (sides.s) {\n    x += deltaY1 * -sin;\n    y += deltaY1 * (1 + cos);\n    x += deltaY2 * sin;\n    y += deltaY2 * (1 - cos);\n  }\n  return [x, y];\n};\n\nexport const getFlipAdjustment = (\n  side: \"n\" | \"s\" | \"w\" | \"e\" | \"nw\" | \"ne\" | \"sw\" | \"se\",\n  nextWidth: number,\n  nextHeight: number,\n  nextX1: number,\n  nextY1: number,\n  nextX2: number,\n  nextY2: number,\n  finalX1: number,\n  finalY1: number,\n  finalX2: number,\n  finalY2: number,\n  needsRotation: boolean,\n  angle: number,\n): [number, number] => {\n  const cos = Math.cos(angle);\n  const sin = Math.sin(angle);\n  let flipDiffX = 0;\n  let flipDiffY = 0;\n  if (nextWidth < 0) {\n    if (side === \"e\" || side === \"ne\" || side === \"se\") {\n      if (needsRotation) {\n        flipDiffX += (finalX2 - nextX1) * cos;\n        flipDiffY += (finalX2 - nextX1) * sin;\n      } else {\n        flipDiffX += finalX2 - nextX1;\n      }\n    }\n    if (side === \"w\" || side === \"nw\" || side === \"sw\") {\n      if (needsRotation) {\n        flipDiffX += (finalX1 - nextX2) * cos;\n        flipDiffY += (finalX1 - nextX2) * sin;\n      } else {\n        flipDiffX += finalX1 - nextX2;\n      }\n    }\n  }\n  if (nextHeight < 0) {\n    if (side === \"s\" || side === \"se\" || side === \"sw\") {\n      if (needsRotation) {\n        flipDiffY += (finalY2 - nextY1) * cos;\n        flipDiffX += (finalY2 - nextY1) * -sin;\n      } else {\n        flipDiffY += finalY2 - nextY1;\n      }\n    }\n    if (side === \"n\" || side === \"ne\" || side === \"nw\") {\n      if (needsRotation) {\n        flipDiffY += (finalY1 - nextY2) * cos;\n        flipDiffX += (finalY1 - nextY2) * -sin;\n      } else {\n        flipDiffY += finalY1 - nextY2;\n      }\n    }\n  }\n  return [flipDiffX, flipDiffY];\n};\n\nexport const getPointOnAPath = (point: Point, path: Point[]) => {\n  const [px, py] = point;\n  const [start, ...other] = path;\n  let [lastX, lastY] = start;\n  let kLine: number = 0;\n  let idx: number = 0;\n\n  // if any item in the array is true, it means that a point is\n  // on some segment of a line based path\n  const retVal = other.some(([x2, y2], i) => {\n    // we always take a line when dealing with line segments\n    const x1 = lastX;\n    const y1 = lastY;\n\n    lastX = x2;\n    lastY = y2;\n\n    // if a point is not within the domain of the line segment\n    // it is not on the line segment\n    if (px < x1 || px > x2) {\n      return false;\n    }\n\n    // check if all points lie on the same line\n    // y1 = kx1 + b, y2 = kx2 + b\n    // y2 - y1 = k(x2 - x2) -> k = (y2 - y1) / (x2 - x1)\n\n    // coefficient for the line (p0, p1)\n    const kL = (y2 - y1) / (x2 - x1);\n\n    // coefficient for the line segment (p0, point)\n    const kP1 = (py - y1) / (px - x1);\n\n    // coefficient for the line segment (point, p1)\n    const kP2 = (py - y2) / (px - x2);\n\n    // because we are basing both lines from the same starting point\n    // the only option for collinearity is having same coefficients\n\n    // using it for floating point comparisons\n    const epsilon = 0.3;\n\n    // if coefficient is more than an arbitrary epsilon,\n    // these lines are nor collinear\n    if (Math.abs(kP1 - kL) > epsilon && Math.abs(kP2 - kL) > epsilon) {\n      return false;\n    }\n\n    // store the coefficient because we are goint to need it\n    kLine = kL;\n    idx = i;\n\n    return true;\n  });\n\n  // Return a coordinate that is always on the line segment\n  if (retVal === true) {\n    return { x: point[0], y: kLine * point[0], segment: idx };\n  }\n\n  return null;\n};\n\nexport const distance2d = (x1: number, y1: number, x2: number, y2: number) => {\n  const xd = x2 - x1;\n  const yd = y2 - y1;\n  return Math.hypot(xd, yd);\n};\n\n// Checks if the first and last point are close enough\n// to be considered a loop\nexport const isPathALoop = (\n  points: ExcalidrawLinearElement[\"points\"],\n): boolean => {\n  if (points.length >= 3) {\n    const [firstPoint, lastPoint] = [points[0], points[points.length - 1]];\n    return (\n      distance2d(firstPoint[0], firstPoint[1], lastPoint[0], lastPoint[1]) <=\n      LINE_CONFIRM_THRESHOLD\n    );\n  }\n  return false;\n};\n\n// Draw a line from the point to the right till infiinty\n// Check how many lines of the polygon does this infinite line intersects with\n// If the number of intersections is odd, point is in the polygon\nexport const isPointInPolygon = (\n  points: Point[],\n  x: number,\n  y: number,\n): boolean => {\n  const vertices = points.length;\n\n  // There must be at least 3 vertices in polygon\n  if (vertices < 3) {\n    return false;\n  }\n  const extreme: Point = [Number.MAX_SAFE_INTEGER, y];\n  const p: Point = [x, y];\n  let count = 0;\n  for (let i = 0; i < vertices; i++) {\n    const current = points[i];\n    const next = points[(i + 1) % vertices];\n    if (doIntersect(current, next, p, extreme)) {\n      if (orientation(current, p, next) === 0) {\n        return onSegment(current, p, next);\n      }\n      count++;\n    }\n  }\n  // true if count is off\n  return count % 2 === 1;\n};\n\n// Check if q lies on the line segment pr\nconst onSegment = (p: Point, q: Point, r: Point) => {\n  return (\n    q[0] <= Math.max(p[0], r[0]) &&\n    q[0] >= Math.min(p[0], r[0]) &&\n    q[1] <= Math.max(p[1], r[1]) &&\n    q[1] >= Math.min(p[1], r[1])\n  );\n};\n\n// For the ordered points p, q, r, return\n// 0 if p, q, r are collinear\n// 1 if Clockwise\n// 2 if counterclickwise\nconst orientation = (p: Point, q: Point, r: Point) => {\n  const val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1]);\n  if (val === 0) {\n    return 0;\n  }\n  return val > 0 ? 1 : 2;\n};\n\n// Check is p1q1 intersects with p2q2\nconst doIntersect = (p1: Point, q1: Point, p2: Point, q2: Point) => {\n  const o1 = orientation(p1, q1, p2);\n  const o2 = orientation(p1, q1, q2);\n  const o3 = orientation(p2, q2, p1);\n  const o4 = orientation(p2, q2, q1);\n\n  if (o1 !== o2 && o3 !== o4) {\n    return true;\n  }\n\n  // p1, q1 and p2 are colinear and p2 lies on segment p1q1\n  if (o1 === 0 && onSegment(p1, p2, q1)) {\n    return true;\n  }\n\n  // p1, q1 and p2 are colinear and q2 lies on segment p1q1\n  if (o2 === 0 && onSegment(p1, q2, q1)) {\n    return true;\n  }\n\n  // p2, q2 and p1 are colinear and p1 lies on segment p2q2\n  if (o3 === 0 && onSegment(p2, p1, q2)) {\n    return true;\n  }\n\n  // p2, q2 and q1 are colinear and q1 lies on segment p2q2\n  if (o4 === 0 && onSegment(p2, q1, q2)) {\n    return true;\n  }\n\n  return false;\n};\n\nexport const getGridPoint = (\n  x: number,\n  y: number,\n  gridSize: number | null,\n): [number, number] => {\n  if (gridSize) {\n    return [\n      Math.round(x / gridSize) * gridSize,\n      Math.round(y / gridSize) * gridSize,\n    ];\n  }\n  return [x, y];\n};\n","import { FlooredNumber } from \"./types\";\nimport { getZoomOrigin } from \"./scene\";\nimport { CURSOR_TYPE, FONT_FAMILY } from \"./constants\";\nimport { FontFamily, FontString } from \"./element/types\";\n\nexport const SVG_NS = \"http://www.w3.org/2000/svg\";\n\nlet mockDateTime: string | null = null;\n\nexport const setDateTimeForTests = (dateTime: string) => {\n  mockDateTime = dateTime;\n};\n\nexport const getDateTime = () => {\n  if (mockDateTime) {\n    return mockDateTime;\n  }\n\n  const date = new Date();\n  const year = date.getFullYear();\n  const month = `${date.getMonth() + 1}`.padStart(2, \"0\");\n  const day = `${date.getDate()}`.padStart(2, \"0\");\n  const hr = `${date.getHours()}`.padStart(2, \"0\");\n  const min = `${date.getMinutes()}`.padStart(2, \"0\");\n\n  return `${year}-${month}-${day}-${hr}${min}`;\n};\n\nexport const capitalizeString = (str: string) =>\n  str.charAt(0).toUpperCase() + str.slice(1);\n\nexport const isToolIcon = (\n  target: Element | EventTarget | null,\n): target is HTMLElement =>\n  target instanceof HTMLElement && target.className.includes(\"ToolIcon\");\n\nexport const isInputLike = (\n  target: Element | EventTarget | null,\n): target is\n  | HTMLInputElement\n  | HTMLTextAreaElement\n  | HTMLSelectElement\n  | HTMLBRElement\n  | HTMLDivElement =>\n  (target instanceof HTMLElement && target.dataset.type === \"wysiwyg\") ||\n  target instanceof HTMLBRElement || // newline in wysiwyg\n  target instanceof HTMLInputElement ||\n  target instanceof HTMLTextAreaElement ||\n  target instanceof HTMLSelectElement;\n\nexport const isWritableElement = (\n  target: Element | EventTarget | null,\n): target is\n  | HTMLInputElement\n  | HTMLTextAreaElement\n  | HTMLBRElement\n  | HTMLDivElement =>\n  (target instanceof HTMLElement && target.dataset.type === \"wysiwyg\") ||\n  target instanceof HTMLBRElement || // newline in wysiwyg\n  target instanceof HTMLTextAreaElement ||\n  (target instanceof HTMLInputElement &&\n    (target.type === \"text\" || target.type === \"number\"));\n\nexport const getFontFamilyString = ({\n  fontFamily,\n}: {\n  fontFamily: FontFamily;\n}) => {\n  return FONT_FAMILY[fontFamily];\n};\n\n/** returns fontSize+fontFamily string for assignment to DOM elements */\nexport const getFontString = ({\n  fontSize,\n  fontFamily,\n}: {\n  fontSize: number;\n  fontFamily: FontFamily;\n}) => {\n  return `${fontSize}px ${getFontFamilyString({ fontFamily })}` as FontString;\n};\n\n// https://github.com/grassator/canvas-text-editor/blob/master/lib/FontMetrics.js\nexport const measureText = (text: string, font: FontString) => {\n  const line = document.createElement(\"div\");\n  const body = document.body;\n  line.style.position = \"absolute\";\n  line.style.whiteSpace = \"pre\";\n  line.style.font = font;\n  body.appendChild(line);\n  line.innerText = text\n    .split(\"\\n\")\n    // replace empty lines with single space because leading/trailing empty\n    //  lines would be stripped from computation\n    .map((x) => x || \" \")\n    .join(\"\\n\");\n  const width = line.offsetWidth;\n  const height = line.offsetHeight;\n  // Now creating 1px sized item that will be aligned to baseline\n  // to calculate baseline shift\n  const span = document.createElement(\"span\");\n  span.style.display = \"inline-block\";\n  span.style.overflow = \"hidden\";\n  span.style.width = \"1px\";\n  span.style.height = \"1px\";\n  line.appendChild(span);\n  // Baseline is important for positioning text on canvas\n  const baseline = span.offsetTop + span.offsetHeight;\n  document.body.removeChild(line);\n\n  return { width, height, baseline };\n};\n\nexport const debounce = <T extends any[]>(\n  fn: (...args: T) => void,\n  timeout: number,\n) => {\n  let handle = 0;\n  let lastArgs: T;\n  const ret = (...args: T) => {\n    lastArgs = args;\n    clearTimeout(handle);\n    handle = window.setTimeout(() => fn(...args), timeout);\n  };\n  ret.flush = () => {\n    clearTimeout(handle);\n    fn(...lastArgs);\n  };\n  return ret;\n};\n\nexport const selectNode = (node: Element) => {\n  const selection = window.getSelection();\n  if (selection) {\n    const range = document.createRange();\n    range.selectNodeContents(node);\n    selection.removeAllRanges();\n    selection.addRange(range);\n  }\n};\n\nexport const removeSelection = () => {\n  const selection = window.getSelection();\n  if (selection) {\n    selection.removeAllRanges();\n  }\n};\n\nexport const distance = (x: number, y: number) => Math.abs(x - y);\n\nexport const resetCursor = () => {\n  document.documentElement.style.cursor = \"\";\n};\n\nexport const setCursorForShape = (shape: string) => {\n  if (shape === \"selection\") {\n    resetCursor();\n  } else {\n    document.documentElement.style.cursor = CURSOR_TYPE.CROSSHAIR;\n  }\n};\n\nexport const isFullScreen = () =>\n  document.fullscreenElement?.nodeName === \"HTML\";\n\nexport const allowFullScreen = () =>\n  document.documentElement.requestFullscreen();\n\nexport const exitFullScreen = () => document.exitFullscreen();\n\nexport const getShortcutKey = (shortcut: string): string => {\n  const isMac = /Mac|iPod|iPhone|iPad/.test(window.navigator.platform);\n  if (isMac) {\n    return `${shortcut\n      .replace(/\\bCtrlOrCmd\\b/i, \"Cmd\")\n      .replace(/\\bAlt\\b/i, \"Option\")\n      .replace(/\\bDel\\b/i, \"Delete\")\n      .replace(/\\b(Enter|Return)\\b/i, \"Enter\")}`;\n  }\n  return `${shortcut.replace(/\\bCtrlOrCmd\\b/i, \"Ctrl\")}`;\n};\nexport const viewportCoordsToSceneCoords = (\n  { clientX, clientY }: { clientX: number; clientY: number },\n  {\n    scrollX,\n    scrollY,\n    zoom,\n  }: {\n    scrollX: FlooredNumber;\n    scrollY: FlooredNumber;\n    zoom: number;\n  },\n  canvas: HTMLCanvasElement | null,\n  scale: number,\n) => {\n  const zoomOrigin = getZoomOrigin(canvas, scale);\n  const clientXWithZoom = zoomOrigin.x + (clientX - zoomOrigin.x) / zoom;\n  const clientYWithZoom = zoomOrigin.y + (clientY - zoomOrigin.y) / zoom;\n\n  const x = clientXWithZoom - scrollX;\n  const y = clientYWithZoom - scrollY;\n\n  return { x, y };\n};\n\nexport const sceneCoordsToViewportCoords = (\n  { sceneX, sceneY }: { sceneX: number; sceneY: number },\n  {\n    scrollX,\n    scrollY,\n    zoom,\n  }: {\n    scrollX: FlooredNumber;\n    scrollY: FlooredNumber;\n    zoom: number;\n  },\n  canvas: HTMLCanvasElement | null,\n  scale: number,\n) => {\n  const zoomOrigin = getZoomOrigin(canvas, scale);\n  const x = zoomOrigin.x - (zoomOrigin.x - sceneX - scrollX) * zoom;\n  const y = zoomOrigin.y - (zoomOrigin.y - sceneY - scrollY) * zoom;\n\n  return { x, y };\n};\n\nexport const getGlobalCSSVariable = (name: string) =>\n  getComputedStyle(document.documentElement).getPropertyValue(`--${name}`);\n\nconst RS_LTR_CHARS =\n  \"A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02B8\\u0300-\\u0590\\u0800-\\u1FFF\" +\n  \"\\u2C00-\\uFB1C\\uFDFE-\\uFE6F\\uFEFD-\\uFFFF\";\nconst RS_RTL_CHARS = \"\\u0591-\\u07FF\\uFB1D-\\uFDFD\\uFE70-\\uFEFC\";\nconst RE_RTL_CHECK = new RegExp(`^[^${RS_LTR_CHARS}]*[${RS_RTL_CHARS}]`);\n/**\n * Checks whether first directional character is RTL. Meaning whether it starts\n *  with RTL characters, or indeterminate (numbers etc.) characters followed by\n *  RTL.\n * See https://github.com/excalidraw/excalidraw/pull/1722#discussion_r436340171\n */\nexport const isRTL = (text: string) => {\n  return RE_RTL_CHECK.test(text);\n};\n","import { ExcalidrawElement, ExcalidrawLinearElement } from \"./types\";\nimport { distance2d, rotate } from \"../math\";\nimport rough from \"roughjs/bin/rough\";\nimport { Drawable, Op } from \"roughjs/bin/core\";\nimport { Point } from \"../types\";\nimport {\n  getShapeForElement,\n  generateRoughOptions,\n} from \"../renderer/renderElement\";\nimport { isLinearElement } from \"./typeChecks\";\nimport { rescalePoints } from \"../points\";\n\n// If the element is created from right to left, the width is going to be negative\n// This set of functions retrieves the absolute position of the 4 points.\nexport const getElementAbsoluteCoords = (\n  element: ExcalidrawElement,\n): [number, number, number, number] => {\n  if (isLinearElement(element)) {\n    return getLinearElementAbsoluteCoords(element);\n  }\n  return [\n    element.x,\n    element.y,\n    element.x + element.width,\n    element.y + element.height,\n  ];\n};\n\nexport const getDiamondPoints = (element: ExcalidrawElement) => {\n  // Here we add +1 to avoid these numbers to be 0\n  // otherwise rough.js will throw an error complaining about it\n  const topX = Math.floor(element.width / 2) + 1;\n  const topY = 0;\n  const rightX = element.width;\n  const rightY = Math.floor(element.height / 2) + 1;\n  const bottomX = topX;\n  const bottomY = element.height;\n  const leftX = topY;\n  const leftY = rightY;\n\n  return [topX, topY, rightX, rightY, bottomX, bottomY, leftX, leftY];\n};\n\nexport const getCurvePathOps = (shape: Drawable): Op[] => {\n  for (const set of shape.sets) {\n    if (set.type === \"path\") {\n      return set.ops;\n    }\n  }\n  return shape.sets[0].ops;\n};\n\nconst getMinMaxXYFromCurvePathOps = (\n  ops: Op[],\n  transformXY?: (x: number, y: number) => [number, number],\n): [number, number, number, number] => {\n  let currentP: Point = [0, 0];\n  const { minX, minY, maxX, maxY } = ops.reduce(\n    (limits, { op, data }) => {\n      // There are only four operation types:\n      // move, bcurveTo, lineTo, and curveTo\n      if (op === \"move\") {\n        // change starting point\n        currentP = (data as unknown) as Point;\n        // move operation does not draw anything; so, it always\n        // returns false\n      } else if (op === \"bcurveTo\") {\n        // create points from bezier curve\n        // bezier curve stores data as a flattened array of three positions\n        // [x1, y1, x2, y2, x3, y3]\n        const p1 = [data[0], data[1]] as Point;\n        const p2 = [data[2], data[3]] as Point;\n        const p3 = [data[4], data[5]] as Point;\n\n        const p0 = currentP;\n        currentP = p3;\n\n        const equation = (t: number, idx: number) =>\n          Math.pow(1 - t, 3) * p3[idx] +\n          3 * t * Math.pow(1 - t, 2) * p2[idx] +\n          3 * Math.pow(t, 2) * (1 - t) * p1[idx] +\n          p0[idx] * Math.pow(t, 3);\n\n        let t = 0;\n        while (t <= 1.0) {\n          let x = equation(t, 0);\n          let y = equation(t, 1);\n          if (transformXY) {\n            [x, y] = transformXY(x, y);\n          }\n\n          limits.minY = Math.min(limits.minY, y);\n          limits.minX = Math.min(limits.minX, x);\n\n          limits.maxX = Math.max(limits.maxX, x);\n          limits.maxY = Math.max(limits.maxY, y);\n\n          t += 0.1;\n        }\n      } else if (op === \"lineTo\") {\n        // TODO: Implement this\n      } else if (op === \"qcurveTo\") {\n        // TODO: Implement this\n      }\n      return limits;\n    },\n    { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity },\n  );\n\n  return [minX, minY, maxX, maxY];\n};\n\nconst getLinearElementAbsoluteCoords = (\n  element: ExcalidrawLinearElement,\n): [number, number, number, number] => {\n  if (element.points.length < 2 || !getShapeForElement(element)) {\n    // XXX this is just a poor estimate and not very useful\n    const { minX, minY, maxX, maxY } = element.points.reduce(\n      (limits, [x, y]) => {\n        limits.minY = Math.min(limits.minY, y);\n        limits.minX = Math.min(limits.minX, x);\n\n        limits.maxX = Math.max(limits.maxX, x);\n        limits.maxY = Math.max(limits.maxY, y);\n\n        return limits;\n      },\n      { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity },\n    );\n    return [\n      minX + element.x,\n      minY + element.y,\n      maxX + element.x,\n      maxY + element.y,\n    ];\n  }\n\n  const shape = getShapeForElement(element) as Drawable[];\n\n  // first element is always the curve\n  const ops = getCurvePathOps(shape[0]);\n\n  const [minX, minY, maxX, maxY] = getMinMaxXYFromCurvePathOps(ops);\n\n  return [\n    minX + element.x,\n    minY + element.y,\n    maxX + element.x,\n    maxY + element.y,\n  ];\n};\n\nexport const getArrowPoints = (\n  element: ExcalidrawLinearElement,\n  shape: Drawable[],\n) => {\n  const ops = getCurvePathOps(shape[0]);\n\n  const data = ops[ops.length - 1].data;\n  const p3 = [data[4], data[5]] as Point;\n  const p2 = [data[2], data[3]] as Point;\n  const p1 = [data[0], data[1]] as Point;\n\n  // we need to find p0 of the bezier curve\n  // it is typically the last point of the previous\n  // curve; it can also be the position of moveTo operation\n  const prevOp = ops[ops.length - 2];\n  let p0: Point = [0, 0];\n  if (prevOp.op === \"move\") {\n    p0 = (prevOp.data as unknown) as Point;\n  } else if (prevOp.op === \"bcurveTo\") {\n    p0 = [prevOp.data[4], prevOp.data[5]];\n  }\n\n  // B(t) = p0 * (1-t)^3 + 3p1 * t * (1-t)^2 + 3p2 * t^2 * (1-t) + p3 * t^3\n  const equation = (t: number, idx: number) =>\n    Math.pow(1 - t, 3) * p3[idx] +\n    3 * t * Math.pow(1 - t, 2) * p2[idx] +\n    3 * Math.pow(t, 2) * (1 - t) * p1[idx] +\n    p0[idx] * Math.pow(t, 3);\n\n  // we know the last point of the arrow\n  const [x2, y2] = p3;\n\n  // by using cubic bezier equation (B(t)) and the given parameters,\n  // we calculate a point that is closer to the last point\n  // The value 0.3 is chosen arbitrarily and it works best for all\n  // the tested cases\n  const [x1, y1] = [equation(0.3, 0), equation(0.3, 1)];\n\n  // find the normalized direction vector based on the\n  // previously calculated points\n  const distance = Math.hypot(x2 - x1, y2 - y1);\n  const nx = (x2 - x1) / distance;\n  const ny = (y2 - y1) / distance;\n\n  const size = 30; // pixels\n  const arrowLength = element.points.reduce((total, [cx, cy], idx, points) => {\n    const [px, py] = idx > 0 ? points[idx - 1] : [0, 0];\n    return total + Math.hypot(cx - px, cy - py);\n  }, 0);\n\n  // Scale down the arrow until we hit a certain size so that it doesn't look weird\n  // This value is selected by minizing a minmum size with the whole length of the arrow\n  // intead of last segment of the arrow\n  const minSize = Math.min(size, arrowLength / 2);\n  const xs = x2 - nx * minSize;\n  const ys = y2 - ny * minSize;\n\n  const angle = 20; // degrees\n  const [x3, y3] = rotate(xs, ys, x2, y2, (-angle * Math.PI) / 180);\n  const [x4, y4] = rotate(xs, ys, x2, y2, (angle * Math.PI) / 180);\n\n  return [x2, y2, x3, y3, x4, y4];\n};\n\nconst getLinearElementRotatedBounds = (\n  element: ExcalidrawLinearElement,\n  cx: number,\n  cy: number,\n): [number, number, number, number] => {\n  if (element.points.length < 2 || !getShapeForElement(element)) {\n    // XXX this is just a poor estimate and not very useful\n    const { minX, minY, maxX, maxY } = element.points.reduce(\n      (limits, [x, y]) => {\n        [x, y] = rotate(element.x + x, element.y + y, cx, cy, element.angle);\n        limits.minY = Math.min(limits.minY, y);\n        limits.minX = Math.min(limits.minX, x);\n        limits.maxX = Math.max(limits.maxX, x);\n        limits.maxY = Math.max(limits.maxY, y);\n        return limits;\n      },\n      { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity },\n    );\n    return [minX, minY, maxX, maxY];\n  }\n\n  const shape = getShapeForElement(element) as Drawable[];\n\n  // first element is always the curve\n  const ops = getCurvePathOps(shape[0]);\n\n  const transformXY = (x: number, y: number) =>\n    rotate(element.x + x, element.y + y, cx, cy, element.angle);\n  return getMinMaxXYFromCurvePathOps(ops, transformXY);\n};\n\nexport const getElementBounds = (\n  element: ExcalidrawElement,\n): [number, number, number, number] => {\n  const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n  const cx = (x1 + x2) / 2;\n  const cy = (y1 + y2) / 2;\n  if (isLinearElement(element)) {\n    return getLinearElementRotatedBounds(element, cx, cy);\n  }\n  if (element.type === \"diamond\") {\n    const [x11, y11] = rotate(cx, y1, cx, cy, element.angle);\n    const [x12, y12] = rotate(cx, y2, cx, cy, element.angle);\n    const [x22, y22] = rotate(x1, cy, cx, cy, element.angle);\n    const [x21, y21] = rotate(x2, cy, cx, cy, element.angle);\n    const minX = Math.min(x11, x12, x22, x21);\n    const minY = Math.min(y11, y12, y22, y21);\n    const maxX = Math.max(x11, x12, x22, x21);\n    const maxY = Math.max(y11, y12, y22, y21);\n    return [minX, minY, maxX, maxY];\n  }\n  if (element.type === \"ellipse\") {\n    const w = (x2 - x1) / 2;\n    const h = (y2 - y1) / 2;\n    const cos = Math.cos(element.angle);\n    const sin = Math.sin(element.angle);\n    const ww = Math.hypot(w * cos, h * sin);\n    const hh = Math.hypot(h * cos, w * sin);\n    return [cx - ww, cy - hh, cx + ww, cy + hh];\n  }\n  const [x11, y11] = rotate(x1, y1, cx, cy, element.angle);\n  const [x12, y12] = rotate(x1, y2, cx, cy, element.angle);\n  const [x22, y22] = rotate(x2, y2, cx, cy, element.angle);\n  const [x21, y21] = rotate(x2, y1, cx, cy, element.angle);\n  const minX = Math.min(x11, x12, x22, x21);\n  const minY = Math.min(y11, y12, y22, y21);\n  const maxX = Math.max(x11, x12, x22, x21);\n  const maxY = Math.max(y11, y12, y22, y21);\n  return [minX, minY, maxX, maxY];\n};\n\nexport const getCommonBounds = (\n  elements: readonly ExcalidrawElement[],\n): [number, number, number, number] => {\n  if (!elements.length) {\n    return [0, 0, 0, 0];\n  }\n\n  let minX = Infinity;\n  let maxX = -Infinity;\n  let minY = Infinity;\n  let maxY = -Infinity;\n\n  elements.forEach((element) => {\n    const [x1, y1, x2, y2] = getElementBounds(element);\n    minX = Math.min(minX, x1);\n    minY = Math.min(minY, y1);\n    maxX = Math.max(maxX, x2);\n    maxY = Math.max(maxY, y2);\n  });\n\n  return [minX, minY, maxX, maxY];\n};\n\nexport const getResizedElementAbsoluteCoords = (\n  element: ExcalidrawElement,\n  nextWidth: number,\n  nextHeight: number,\n): [number, number, number, number] => {\n  if (!isLinearElement(element)) {\n    return [\n      element.x,\n      element.y,\n      element.x + nextWidth,\n      element.y + nextHeight,\n    ];\n  }\n\n  const points = rescalePoints(\n    0,\n    nextWidth,\n    rescalePoints(1, nextHeight, element.points),\n  );\n\n  const gen = rough.generator();\n  const curve = gen.curve(\n    points as [number, number][],\n    generateRoughOptions(element),\n  );\n  const ops = getCurvePathOps(curve);\n  const [minX, minY, maxX, maxY] = getMinMaxXYFromCurvePathOps(ops);\n  return [\n    minX + element.x,\n    minY + element.y,\n    maxX + element.x,\n    maxY + element.y,\n  ];\n};\n\nexport const getElementPointsCoords = (\n  element: ExcalidrawLinearElement,\n  points: readonly (readonly [number, number])[],\n): [number, number, number, number] => {\n  // This might be computationally heavey\n  const gen = rough.generator();\n  const curve = gen.curve(\n    points as [number, number][],\n    generateRoughOptions(element),\n  );\n  const ops = getCurvePathOps(curve);\n  const [minX, minY, maxX, maxY] = getMinMaxXYFromCurvePathOps(ops);\n  return [\n    minX + element.x,\n    minY + element.y,\n    maxX + element.x,\n    maxY + element.y,\n  ];\n};\n\nexport const getClosestElementBounds = (\n  elements: readonly ExcalidrawElement[],\n  from: { x: number; y: number },\n): [number, number, number, number] => {\n  if (!elements.length) {\n    return [0, 0, 0, 0];\n  }\n\n  let minDistance = Infinity;\n  let closestElement = elements[0];\n\n  elements.forEach((element) => {\n    const [x1, y1, x2, y2] = getElementBounds(element);\n    const distance = distance2d((x1 + x2) / 2, (y1 + y2) / 2, from.x, from.y);\n\n    if (distance < minDistance) {\n      minDistance = distance;\n      closestElement = element;\n    }\n  });\n\n  return getElementBounds(closestElement);\n};\n","import { ExcalidrawElement } from \"./types\";\nimport { mutateElement } from \"./mutateElement\";\nimport { isLinearElement } from \"./typeChecks\";\nimport { SHIFT_LOCKING_ANGLE } from \"../constants\";\n\nexport const isInvisiblySmallElement = (\n  element: ExcalidrawElement,\n): boolean => {\n  if (isLinearElement(element)) {\n    return element.points.length < 2;\n  }\n  return element.width === 0 && element.height === 0;\n};\n\n/**\n * Makes a perfect shape or diagonal/horizontal/vertical line\n */\nexport const getPerfectElementSize = (\n  elementType: string,\n  width: number,\n  height: number,\n): { width: number; height: number } => {\n  const absWidth = Math.abs(width);\n  const absHeight = Math.abs(height);\n\n  if (\n    elementType === \"line\" ||\n    elementType === \"arrow\" ||\n    elementType === \"draw\"\n  ) {\n    const lockedAngle =\n      Math.round(Math.atan(absHeight / absWidth) / SHIFT_LOCKING_ANGLE) *\n      SHIFT_LOCKING_ANGLE;\n    if (lockedAngle === 0) {\n      height = 0;\n    } else if (lockedAngle === Math.PI / 2) {\n      width = 0;\n    } else {\n      height =\n        Math.round(absWidth * Math.tan(lockedAngle)) * Math.sign(height) ||\n        height;\n    }\n  } else if (elementType !== \"selection\") {\n    height = absWidth * Math.sign(height);\n  }\n  return { width, height };\n};\n\nexport const resizePerfectLineForNWHandler = (\n  element: ExcalidrawElement,\n  x: number,\n  y: number,\n) => {\n  const anchorX = element.x + element.width;\n  const anchorY = element.y + element.height;\n  const distanceToAnchorX = x - anchorX;\n  const distanceToAnchorY = y - anchorY;\n  if (Math.abs(distanceToAnchorX) < Math.abs(distanceToAnchorY) / 2) {\n    mutateElement(element, {\n      x: anchorX,\n      width: 0,\n      y,\n      height: -distanceToAnchorY,\n    });\n  } else if (Math.abs(distanceToAnchorY) < Math.abs(element.width) / 2) {\n    mutateElement(element, {\n      y: anchorY,\n      height: 0,\n    });\n  } else {\n    const nextHeight =\n      Math.sign(distanceToAnchorY) *\n      Math.sign(distanceToAnchorX) *\n      element.width;\n    mutateElement(element, {\n      x,\n      y: anchorY - nextHeight,\n      width: -distanceToAnchorX,\n      height: nextHeight,\n    });\n  }\n};\n\nexport const getNormalizedDimensions = (\n  element: Pick<ExcalidrawElement, \"width\" | \"height\" | \"x\" | \"y\">,\n): {\n  width: ExcalidrawElement[\"width\"];\n  height: ExcalidrawElement[\"height\"];\n  x: ExcalidrawElement[\"x\"];\n  y: ExcalidrawElement[\"y\"];\n} => {\n  const ret = {\n    width: element.width,\n    height: element.height,\n    x: element.x,\n    y: element.y,\n  };\n\n  if (element.width < 0) {\n    const nextWidth = Math.abs(element.width);\n    ret.width = nextWidth;\n    ret.x = element.x - nextWidth;\n  }\n\n  if (element.height < 0) {\n    const nextHeight = Math.abs(element.height);\n    ret.height = nextHeight;\n    ret.y = element.y - nextHeight;\n  }\n\n  return ret;\n};\n","import {\n  ExcalidrawElement,\n  ExcalidrawTextElement,\n  ExcalidrawLinearElement,\n  ExcalidrawGenericElement,\n  NonDeleted,\n  TextAlign,\n  FontFamily,\n  GroupId,\n  VerticalAlign,\n} from \"../element/types\";\nimport { measureText, getFontString } from \"../utils\";\nimport { randomInteger, randomId } from \"../random\";\nimport { newElementWith } from \"./mutateElement\";\nimport { getNewGroupIdsForDuplication } from \"../groups\";\nimport { AppState } from \"../types\";\nimport { getElementAbsoluteCoords } from \".\";\nimport { adjustXYWithRotation } from \"../math\";\nimport { getResizedElementAbsoluteCoords } from \"./bounds\";\n\ntype ElementConstructorOpts = MarkOptional<\n  Omit<ExcalidrawGenericElement, \"id\" | \"type\" | \"isDeleted\">,\n  | \"width\"\n  | \"height\"\n  | \"angle\"\n  | \"groupIds\"\n  | \"seed\"\n  | \"version\"\n  | \"versionNonce\"\n>;\n\nconst _newElementBase = <T extends ExcalidrawElement>(\n  type: T[\"type\"],\n  {\n    x,\n    y,\n    strokeColor,\n    backgroundColor,\n    fillStyle,\n    strokeWidth,\n    strokeStyle,\n    roughness,\n    opacity,\n    width = 0,\n    height = 0,\n    angle = 0,\n    groupIds = [],\n    ...rest\n  }: ElementConstructorOpts & Omit<Partial<ExcalidrawGenericElement>, \"type\">,\n) => ({\n  id: rest.id || randomId(),\n  type,\n  x,\n  y,\n  width,\n  height,\n  angle,\n  strokeColor,\n  backgroundColor,\n  fillStyle,\n  strokeWidth,\n  strokeStyle,\n  roughness,\n  opacity,\n  groupIds,\n  seed: rest.seed ?? randomInteger(),\n  version: rest.version || 1,\n  versionNonce: rest.versionNonce ?? 0,\n  isDeleted: false as false,\n});\n\nexport const newElement = (\n  opts: {\n    type: ExcalidrawGenericElement[\"type\"];\n  } & ElementConstructorOpts,\n): NonDeleted<ExcalidrawGenericElement> =>\n  _newElementBase<ExcalidrawGenericElement>(opts.type, opts);\n\n/** computes element x/y offset based on textAlign/verticalAlign */\nfunction getTextElementPositionOffsets(\n  opts: {\n    textAlign: ExcalidrawTextElement[\"textAlign\"];\n    verticalAlign: ExcalidrawTextElement[\"verticalAlign\"];\n  },\n  metrics: {\n    width: number;\n    height: number;\n  },\n) {\n  return {\n    x:\n      opts.textAlign === \"center\"\n        ? metrics.width / 2\n        : opts.textAlign === \"right\"\n        ? metrics.width\n        : 0,\n    y: opts.verticalAlign === \"middle\" ? metrics.height / 2 : 0,\n  };\n}\n\nexport const newTextElement = (\n  opts: {\n    text: string;\n    fontSize: number;\n    fontFamily: FontFamily;\n    textAlign: TextAlign;\n    verticalAlign: VerticalAlign;\n  } & ElementConstructorOpts,\n): NonDeleted<ExcalidrawTextElement> => {\n  const metrics = measureText(opts.text, getFontString(opts));\n  const offsets = getTextElementPositionOffsets(opts, metrics);\n  const textElement = newElementWith(\n    {\n      ..._newElementBase<ExcalidrawTextElement>(\"text\", opts),\n      text: opts.text,\n      fontSize: opts.fontSize,\n      fontFamily: opts.fontFamily,\n      textAlign: opts.textAlign,\n      verticalAlign: opts.verticalAlign,\n      x: opts.x - offsets.x,\n      y: opts.y - offsets.y,\n      width: metrics.width,\n      height: metrics.height,\n      baseline: metrics.baseline,\n    },\n    {},\n  );\n\n  return textElement;\n};\n\nconst getAdjustedDimensions = (\n  element: ExcalidrawTextElement,\n  nextText: string,\n): {\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n  baseline: number;\n} => {\n  const {\n    width: nextWidth,\n    height: nextHeight,\n    baseline: nextBaseline,\n  } = measureText(nextText, getFontString(element));\n\n  const { textAlign, verticalAlign } = element;\n\n  let x, y;\n\n  if (textAlign === \"center\" && verticalAlign === \"middle\") {\n    const prevMetrics = measureText(element.text, getFontString(element));\n    const offsets = getTextElementPositionOffsets(element, {\n      width: nextWidth - prevMetrics.width,\n      height: nextHeight - prevMetrics.height,\n    });\n\n    x = element.x - offsets.x;\n    y = element.y - offsets.y;\n  } else {\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n\n    const [nextX1, nextY1, nextX2, nextY2] = getResizedElementAbsoluteCoords(\n      element,\n      nextWidth,\n      nextHeight,\n    );\n    const deltaX1 = (x1 - nextX1) / 2;\n    const deltaY1 = (y1 - nextY1) / 2;\n    const deltaX2 = (x2 - nextX2) / 2;\n    const deltaY2 = (y2 - nextY2) / 2;\n\n    [x, y] = adjustXYWithRotation(\n      {\n        s: true,\n        e: textAlign === \"center\" || textAlign === \"left\",\n        w: textAlign === \"center\" || textAlign === \"right\",\n      },\n      element.x,\n      element.y,\n      element.angle,\n      deltaX1,\n      deltaY1,\n      deltaX2,\n      deltaY2,\n    );\n  }\n\n  return {\n    width: nextWidth,\n    height: nextHeight,\n    x: Number.isFinite(x) ? x : element.x,\n    y: Number.isFinite(y) ? y : element.y,\n    baseline: nextBaseline,\n  };\n};\n\nexport const updateTextElement = (\n  element: ExcalidrawTextElement,\n  { text, isDeleted }: { text: string; isDeleted?: boolean },\n): ExcalidrawTextElement => {\n  return newElementWith(element, {\n    text,\n    isDeleted: isDeleted ?? element.isDeleted,\n    ...getAdjustedDimensions(element, text),\n  });\n};\n\nexport const newLinearElement = (\n  opts: {\n    type: ExcalidrawLinearElement[\"type\"];\n    lastCommittedPoint?: ExcalidrawLinearElement[\"lastCommittedPoint\"];\n  } & ElementConstructorOpts,\n): NonDeleted<ExcalidrawLinearElement> => {\n  return {\n    ..._newElementBase<ExcalidrawLinearElement>(opts.type, opts),\n    points: [],\n    lastCommittedPoint: opts.lastCommittedPoint || null,\n  };\n};\n\n// Simplified deep clone for the purpose of cloning ExcalidrawElement only\n//  (doesn't clone Date, RegExp, Map, Set, Typed arrays etc.)\n//\n// Adapted from https://github.com/lukeed/klona\nexport const deepCopyElement = (val: any, depth: number = 0) => {\n  if (val == null || typeof val !== \"object\") {\n    return val;\n  }\n\n  if (Object.prototype.toString.call(val) === \"[object Object]\") {\n    const tmp =\n      typeof val.constructor === \"function\"\n        ? Object.create(Object.getPrototypeOf(val))\n        : {};\n    for (const key in val) {\n      if (val.hasOwnProperty(key)) {\n        // don't copy top-level shape property, which we want to regenerate\n        if (depth === 0 && (key === \"shape\" || key === \"canvas\")) {\n          continue;\n        }\n        tmp[key] = deepCopyElement(val[key], depth + 1);\n      }\n    }\n    return tmp;\n  }\n\n  if (Array.isArray(val)) {\n    let k = val.length;\n    const arr = new Array(k);\n    while (k--) {\n      arr[k] = deepCopyElement(val[k], depth + 1);\n    }\n    return arr;\n  }\n\n  return val;\n};\n\n/**\n * Duplicate an element, often used in the alt-drag operation.\n * Note that this method has gotten a bit complicated since the\n * introduction of gruoping/ungrouping elements.\n * @param editingGroupId The current group being edited. The new\n *                       element will inherit this group and its\n *                       parents.\n * @param groupIdMapForOperation A Map that maps old group IDs to\n *                               duplicated ones. If you are duplicating\n *                               multiple elements at once, share this map\n *                               amongst all of them\n * @param element Element to duplicate\n * @param overrides Any element properties to override\n */\nexport const duplicateElement = <TElement extends Mutable<ExcalidrawElement>>(\n  editingGroupId: AppState[\"editingGroupId\"],\n  groupIdMapForOperation: Map<GroupId, GroupId>,\n  element: TElement,\n  overrides?: Partial<TElement>,\n): TElement => {\n  let copy: TElement = deepCopyElement(element);\n  copy.id = randomId();\n  copy.seed = randomInteger();\n  copy.groupIds = getNewGroupIdsForDuplication(\n    copy.groupIds,\n    editingGroupId,\n    (groupId) => {\n      if (!groupIdMapForOperation.has(groupId)) {\n        groupIdMapForOperation.set(groupId, randomId());\n      }\n      return groupIdMapForOperation.get(groupId)!;\n    },\n  );\n  if (overrides) {\n    copy = Object.assign(copy, overrides);\n  }\n  return copy;\n};\n","import { ExcalidrawElement, PointerType } from \"./types\";\n\nimport { getElementAbsoluteCoords } from \"./bounds\";\nimport { rotate } from \"../math\";\n\ntype Sides = \"n\" | \"s\" | \"w\" | \"e\" | \"nw\" | \"ne\" | \"sw\" | \"se\" | \"rotation\";\n\nconst handleSizes: { [k in PointerType]: number } = {\n  mouse: 8,\n  pen: 16,\n  touch: 28,\n};\n\nconst ROTATION_HANDLER_GAP = 16;\n\nexport const OMIT_SIDES_FOR_MULTIPLE_ELEMENTS = {\n  e: true,\n  s: true,\n  n: true,\n  w: true,\n  rotation: true,\n};\n\nconst OMIT_SIDES_FOR_TEXT_ELEMENT = {\n  e: true,\n  s: true,\n  n: true,\n  w: true,\n};\n\nconst OMIT_SIDES_FOR_LINE_SLASH = {\n  e: true,\n  s: true,\n  n: true,\n  w: true,\n  nw: true,\n  se: true,\n  rotation: true,\n};\n\nconst OMIT_SIDES_FOR_LINE_BACKSLASH = {\n  e: true,\n  s: true,\n  n: true,\n  w: true,\n  ne: true,\n  sw: true,\n  rotation: true,\n};\n\nconst generateHandler = (\n  x: number,\n  y: number,\n  width: number,\n  height: number,\n  cx: number,\n  cy: number,\n  angle: number,\n): [number, number, number, number] => {\n  const [xx, yy] = rotate(x + width / 2, y + height / 2, cx, cy, angle);\n  return [xx - width / 2, yy - height / 2, width, height];\n};\n\nexport const handlerRectanglesFromCoords = (\n  [x1, y1, x2, y2]: [number, number, number, number],\n  angle: number,\n  zoom: number,\n  pointerType: PointerType = \"mouse\",\n  omitSides: { [T in Sides]?: boolean } = {},\n): Partial<{ [T in Sides]: [number, number, number, number] }> => {\n  const size = handleSizes[pointerType];\n  const handlerWidth = size / zoom;\n  const handlerHeight = size / zoom;\n\n  const handlerMarginX = size / zoom;\n  const handlerMarginY = size / zoom;\n\n  const width = x2 - x1;\n  const height = y2 - y1;\n  const cx = (x1 + x2) / 2;\n  const cy = (y1 + y2) / 2;\n\n  const dashedLineMargin = 4 / zoom;\n\n  const centeringOffset = (size - 8) / (2 * zoom);\n\n  const handlers: Partial<\n    { [T in Sides]: [number, number, number, number] }\n  > = {\n    nw: omitSides[\"nw\"]\n      ? undefined\n      : generateHandler(\n          x1 - dashedLineMargin - handlerMarginX + centeringOffset,\n          y1 - dashedLineMargin - handlerMarginY + centeringOffset,\n          handlerWidth,\n          handlerHeight,\n          cx,\n          cy,\n          angle,\n        ),\n    ne: omitSides[\"ne\"]\n      ? undefined\n      : generateHandler(\n          x2 + dashedLineMargin - centeringOffset,\n          y1 - dashedLineMargin - handlerMarginY + centeringOffset,\n          handlerWidth,\n          handlerHeight,\n          cx,\n          cy,\n          angle,\n        ),\n    sw: omitSides[\"sw\"]\n      ? undefined\n      : generateHandler(\n          x1 - dashedLineMargin - handlerMarginX + centeringOffset,\n          y2 + dashedLineMargin - centeringOffset,\n          handlerWidth,\n          handlerHeight,\n          cx,\n          cy,\n          angle,\n        ),\n    se: omitSides[\"se\"]\n      ? undefined\n      : generateHandler(\n          x2 + dashedLineMargin - centeringOffset,\n          y2 + dashedLineMargin - centeringOffset,\n          handlerWidth,\n          handlerHeight,\n          cx,\n          cy,\n          angle,\n        ),\n    rotation: omitSides[\"rotation\"]\n      ? undefined\n      : generateHandler(\n          x1 + width / 2 - handlerWidth / 2,\n          y1 -\n            dashedLineMargin -\n            handlerMarginY +\n            centeringOffset -\n            ROTATION_HANDLER_GAP / zoom,\n          handlerWidth,\n          handlerHeight,\n          cx,\n          cy,\n          angle,\n        ),\n  };\n\n  // We only want to show height handlers (all cardinal directions)  above a certain size\n  const minimumSizeForEightHandlers = (5 * size) / zoom;\n  if (Math.abs(width) > minimumSizeForEightHandlers) {\n    if (!omitSides[\"n\"]) {\n      handlers[\"n\"] = generateHandler(\n        x1 + width / 2 - handlerWidth / 2,\n        y1 - dashedLineMargin - handlerMarginY + centeringOffset,\n        handlerWidth,\n        handlerHeight,\n        cx,\n        cy,\n        angle,\n      );\n    }\n    if (!omitSides[\"s\"]) {\n      handlers[\"s\"] = generateHandler(\n        x1 + width / 2 - handlerWidth / 2,\n        y2 + dashedLineMargin - centeringOffset,\n        handlerWidth,\n        handlerHeight,\n        cx,\n        cy,\n        angle,\n      );\n    }\n  }\n  if (Math.abs(height) > minimumSizeForEightHandlers) {\n    if (!omitSides[\"w\"]) {\n      handlers[\"w\"] = generateHandler(\n        x1 - dashedLineMargin - handlerMarginX + centeringOffset,\n        y1 + height / 2 - handlerHeight / 2,\n        handlerWidth,\n        handlerHeight,\n        cx,\n        cy,\n        angle,\n      );\n    }\n    if (!omitSides[\"e\"]) {\n      handlers[\"e\"] = generateHandler(\n        x2 + dashedLineMargin - centeringOffset,\n        y1 + height / 2 - handlerHeight / 2,\n        handlerWidth,\n        handlerHeight,\n        cx,\n        cy,\n        angle,\n      );\n    }\n  }\n\n  return handlers;\n};\n\nexport const handlerRectangles = (\n  element: ExcalidrawElement,\n  zoom: number,\n  pointerType: PointerType = \"mouse\",\n) => {\n  let omitSides: { [T in Sides]?: boolean } = {};\n  if (\n    element.type === \"arrow\" ||\n    element.type === \"line\" ||\n    element.type === \"draw\"\n  ) {\n    if (element.points.length === 2) {\n      // only check the last point because starting point is always (0,0)\n      const [, p1] = element.points;\n      if (p1[0] === 0 || p1[1] === 0) {\n        omitSides = OMIT_SIDES_FOR_LINE_BACKSLASH;\n      } else if (p1[0] > 0 && p1[1] < 0) {\n        omitSides = OMIT_SIDES_FOR_LINE_SLASH;\n      } else if (p1[0] > 0 && p1[1] > 0) {\n        omitSides = OMIT_SIDES_FOR_LINE_BACKSLASH;\n      } else if (p1[0] < 0 && p1[1] > 0) {\n        omitSides = OMIT_SIDES_FOR_LINE_SLASH;\n      } else if (p1[0] < 0 && p1[1] < 0) {\n        omitSides = OMIT_SIDES_FOR_LINE_BACKSLASH;\n      }\n    }\n  } else if (element.type === \"text\") {\n    omitSides = OMIT_SIDES_FOR_TEXT_ELEMENT;\n  }\n\n  return handlerRectanglesFromCoords(\n    getElementAbsoluteCoords(element),\n    element.angle,\n    zoom,\n    pointerType,\n    omitSides,\n  );\n};\n","import {\n  distanceBetweenPointAndSegment,\n  isPathALoop,\n  rotate,\n  isPointInPolygon,\n} from \"../math\";\nimport { pointsOnBezierCurves } from \"points-on-curve\";\n\nimport { NonDeletedExcalidrawElement } from \"./types\";\n\nimport {\n  getDiamondPoints,\n  getElementAbsoluteCoords,\n  getCurvePathOps,\n} from \"./bounds\";\nimport { Point } from \"../types\";\nimport { Drawable } from \"roughjs/bin/core\";\nimport { AppState } from \"../types\";\nimport { getShapeForElement } from \"../renderer/renderElement\";\nimport { isLinearElement } from \"./typeChecks\";\n\nconst isElementDraggableFromInside = (\n  element: NonDeletedExcalidrawElement,\n  appState: AppState,\n): boolean => {\n  if (element.type === \"arrow\") {\n    return false;\n  }\n  const dragFromInside =\n    element.backgroundColor !== \"transparent\" ||\n    appState.selectedElementIds[element.id];\n  if (element.type === \"line\" || element.type === \"draw\") {\n    return dragFromInside && isPathALoop(element.points);\n  }\n  return dragFromInside;\n};\n\nexport const hitTest = (\n  element: NonDeletedExcalidrawElement,\n  appState: AppState,\n  x: number,\n  y: number,\n  zoom: number,\n): boolean => {\n  // For shapes that are composed of lines, we only enable point-selection when the distance\n  // of the click is less than x pixels of any of the lines that the shape is composed of\n  const lineThreshold = 10 / zoom;\n\n  const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n  const cx = (x1 + x2) / 2;\n  const cy = (y1 + y2) / 2;\n  // reverse rotate the pointer\n  [x, y] = rotate(x, y, cx, cy, -element.angle);\n\n  if (element.type === \"ellipse\") {\n    // https://stackoverflow.com/a/46007540/232122\n    const px = Math.abs(x - element.x - element.width / 2);\n    const py = Math.abs(y - element.y - element.height / 2);\n\n    let tx = 0.707;\n    let ty = 0.707;\n\n    const a = Math.abs(element.width) / 2;\n    const b = Math.abs(element.height) / 2;\n\n    [0, 1, 2, 3].forEach((x) => {\n      const xx = a * tx;\n      const yy = b * ty;\n\n      const ex = ((a * a - b * b) * tx ** 3) / a;\n      const ey = ((b * b - a * a) * ty ** 3) / b;\n\n      const rx = xx - ex;\n      const ry = yy - ey;\n\n      const qx = px - ex;\n      const qy = py - ey;\n\n      const r = Math.hypot(ry, rx);\n      const q = Math.hypot(qy, qx);\n\n      tx = Math.min(1, Math.max(0, ((qx * r) / q + ex) / a));\n      ty = Math.min(1, Math.max(0, ((qy * r) / q + ey) / b));\n      const t = Math.hypot(ty, tx);\n      tx /= t;\n      ty /= t;\n    });\n\n    if (isElementDraggableFromInside(element, appState)) {\n      return (\n        a * tx - (px - lineThreshold) >= 0 && b * ty - (py - lineThreshold) >= 0\n      );\n    }\n    return Math.hypot(a * tx - px, b * ty - py) < lineThreshold;\n  } else if (element.type === \"rectangle\") {\n    if (isElementDraggableFromInside(element, appState)) {\n      return (\n        x > x1 - lineThreshold &&\n        x < x2 + lineThreshold &&\n        y > y1 - lineThreshold &&\n        y < y2 + lineThreshold\n      );\n    }\n\n    // (x1, y1) --A-- (x2, y1)\n    //    |D             |B\n    // (x1, y2) --C-- (x2, y2)\n    return (\n      distanceBetweenPointAndSegment(x, y, x1, y1, x2, y1) < lineThreshold || // A\n      distanceBetweenPointAndSegment(x, y, x2, y1, x2, y2) < lineThreshold || // B\n      distanceBetweenPointAndSegment(x, y, x2, y2, x1, y2) < lineThreshold || // C\n      distanceBetweenPointAndSegment(x, y, x1, y2, x1, y1) < lineThreshold // D\n    );\n  } else if (element.type === \"diamond\") {\n    x -= element.x;\n    y -= element.y;\n    let [\n      topX,\n      topY,\n      rightX,\n      rightY,\n      bottomX,\n      bottomY,\n      leftX,\n      leftY,\n    ] = getDiamondPoints(element);\n\n    if (isElementDraggableFromInside(element, appState)) {\n      // TODO: remove this when we normalize coordinates globally\n      if (topY > bottomY) {\n        [bottomY, topY] = [topY, bottomY];\n      }\n      if (rightX < leftX) {\n        [leftX, rightX] = [rightX, leftX];\n      }\n\n      topY -= lineThreshold;\n      bottomY += lineThreshold;\n      leftX -= lineThreshold;\n      rightX += lineThreshold;\n\n      // all deltas should be < 0. Delta > 0 indicates it's on the outside side\n      //  of the line.\n      //\n      //          (topX, topY)\n      //     D  /             \\ A\n      //      /               \\\n      //  (leftX, leftY)  (rightX, rightY)\n      //    C \\               / B\n      //      \\              /\n      //      (bottomX, bottomY)\n      //\n      // https://stackoverflow.com/a/2752753/927631\n      return (\n        // delta from line D\n        (leftX - topX) * (y - leftY) - (leftX - x) * (topY - leftY) <= 0 &&\n        // delta from line A\n        (topX - rightX) * (y - rightY) - (x - rightX) * (topY - rightY) <= 0 &&\n        // delta from line B\n        (rightX - bottomX) * (y - bottomY) -\n          (x - bottomX) * (rightY - bottomY) <=\n          0 &&\n        // delta from line C\n        (bottomX - leftX) * (y - leftY) - (x - leftX) * (bottomY - leftY) <= 0\n      );\n    }\n\n    return (\n      distanceBetweenPointAndSegment(x, y, topX, topY, rightX, rightY) <\n        lineThreshold ||\n      distanceBetweenPointAndSegment(x, y, rightX, rightY, bottomX, bottomY) <\n        lineThreshold ||\n      distanceBetweenPointAndSegment(x, y, bottomX, bottomY, leftX, leftY) <\n        lineThreshold ||\n      distanceBetweenPointAndSegment(x, y, leftX, leftY, topX, topY) <\n        lineThreshold\n    );\n  } else if (isLinearElement(element)) {\n    if (!getShapeForElement(element)) {\n      return false;\n    }\n    const shape = getShapeForElement(element) as Drawable[];\n\n    if (\n      x < x1 - lineThreshold ||\n      y < y1 - lineThreshold ||\n      x > x2 + lineThreshold ||\n      y > y2 + lineThreshold\n    ) {\n      return false;\n    }\n\n    const relX = x - element.x;\n    const relY = y - element.y;\n\n    if (isElementDraggableFromInside(element, appState)) {\n      const hit = shape.some((subshape) =>\n        hitTestCurveInside(subshape, relX, relY, lineThreshold),\n      );\n      if (hit) {\n        return true;\n      }\n    }\n\n    // hit thest all \"subshapes\" of the linear element\n    return shape.some((subshape) =>\n      hitTestRoughShape(subshape, relX, relY, lineThreshold),\n    );\n  } else if (element.type === \"text\") {\n    return x >= x1 && x <= x2 && y >= y1 && y <= y2;\n  } else if (element.type === \"selection\") {\n    console.warn(\"This should not happen, we need to investigate why it does.\");\n    return false;\n  }\n  throw new Error(`Unimplemented type ${element.type}`);\n};\n\nconst pointInBezierEquation = (\n  p0: Point,\n  p1: Point,\n  p2: Point,\n  p3: Point,\n  [mx, my]: Point,\n  lineThreshold: number,\n) => {\n  // B(t) = p0 * (1-t)^3 + 3p1 * t * (1-t)^2 + 3p2 * t^2 * (1-t) + p3 * t^3\n  const equation = (t: number, idx: number) =>\n    Math.pow(1 - t, 3) * p3[idx] +\n    3 * t * Math.pow(1 - t, 2) * p2[idx] +\n    3 * Math.pow(t, 2) * (1 - t) * p1[idx] +\n    p0[idx] * Math.pow(t, 3);\n\n  // go through t in increments of 0.01\n  let t = 0;\n  while (t <= 1.0) {\n    const tx = equation(t, 0);\n    const ty = equation(t, 1);\n\n    const diff = Math.sqrt(Math.pow(tx - mx, 2) + Math.pow(ty - my, 2));\n\n    if (diff < lineThreshold) {\n      return true;\n    }\n\n    t += 0.01;\n  }\n\n  return false;\n};\n\nconst hitTestCurveInside = (\n  drawable: Drawable,\n  x: number,\n  y: number,\n  lineThreshold: number,\n) => {\n  const ops = getCurvePathOps(drawable);\n  const points: Point[] = [];\n  for (const operation of ops) {\n    if (operation.op === \"move\") {\n      if (points.length) {\n        break;\n      }\n      points.push([operation.data[0], operation.data[1]]);\n    } else if (operation.op === \"bcurveTo\") {\n      points.push([operation.data[0], operation.data[1]]);\n      points.push([operation.data[2], operation.data[3]]);\n      points.push([operation.data[4], operation.data[5]]);\n    }\n  }\n  if (points.length >= 4) {\n    const polygonPoints = pointsOnBezierCurves(points as any, 10, 5);\n    return isPointInPolygon(polygonPoints, x, y);\n  }\n  return false;\n};\n\nconst hitTestRoughShape = (\n  drawable: Drawable,\n  x: number,\n  y: number,\n  lineThreshold: number,\n) => {\n  // read operations from first opSet\n  const ops = getCurvePathOps(drawable);\n\n  // set start position as (0,0) just in case\n  // move operation does not exist (unlikely but it is worth safekeeping it)\n  let currentP: Point = [0, 0];\n\n  return ops.some(({ op, data }, idx) => {\n    // There are only four operation types:\n    // move, bcurveTo, lineTo, and curveTo\n    if (op === \"move\") {\n      // change starting point\n      currentP = (data as unknown) as Point;\n      // move operation does not draw anything; so, it always\n      // returns false\n    } else if (op === \"bcurveTo\") {\n      // create points from bezier curve\n      // bezier curve stores data as a flattened array of three positions\n      // [x1, y1, x2, y2, x3, y3]\n      const p1 = [data[0], data[1]] as Point;\n      const p2 = [data[2], data[3]] as Point;\n      const p3 = [data[4], data[5]] as Point;\n\n      const p0 = currentP;\n      currentP = p3;\n\n      // check if points are on the curve\n      // cubic bezier curves require four parameters\n      // the first parameter is the last stored position (p0)\n      const retVal = pointInBezierEquation(\n        p0,\n        p1,\n        p2,\n        p3,\n        [x, y],\n        lineThreshold,\n      );\n\n      // set end point of bezier curve as the new starting point for\n      // upcoming operations as each operation is based on the last drawn\n      // position of the previous operation\n      return retVal;\n    } else if (op === \"lineTo\") {\n      // TODO: Implement this\n    } else if (op === \"qcurveTo\") {\n      // TODO: Implement this\n    }\n\n    return false;\n  });\n};\n","import {\n  ExcalidrawElement,\n  NonDeletedExcalidrawElement,\n  NonDeleted,\n} from \"./types\";\nimport { isInvisiblySmallElement } from \"./sizeHelpers\";\n\nexport {\n  newElement,\n  newTextElement,\n  updateTextElement,\n  newLinearElement,\n  duplicateElement,\n} from \"./newElement\";\nexport {\n  getElementAbsoluteCoords,\n  getElementBounds,\n  getCommonBounds,\n  getDiamondPoints,\n  getArrowPoints,\n  getClosestElementBounds,\n} from \"./bounds\";\n\nexport {\n  OMIT_SIDES_FOR_MULTIPLE_ELEMENTS,\n  handlerRectanglesFromCoords,\n  handlerRectangles,\n} from \"./handlerRectangles\";\nexport { hitTest } from \"./collision\";\nexport {\n  resizeTest,\n  getCursorForResizingElement,\n  normalizeResizeHandle,\n  getElementWithResizeHandler,\n  getResizeHandlerFromCoords,\n} from \"./resizeTest\";\nexport {\n  resizeElements,\n  getResizeOffsetXY,\n  getResizeArrowDirection,\n} from \"./resizeElements\";\nexport {\n  dragSelectedElements,\n  getDragOffsetXY,\n  dragNewElement,\n} from \"./dragElements\";\nexport { isTextElement, isExcalidrawElement } from \"./typeChecks\";\nexport { textWysiwyg } from \"./textWysiwyg\";\nexport { redrawTextBoundingBox } from \"./textElement\";\nexport {\n  getPerfectElementSize,\n  isInvisiblySmallElement,\n  resizePerfectLineForNWHandler,\n  getNormalizedDimensions,\n} from \"./sizeHelpers\";\nexport { showSelectedShapeActions } from \"./showSelectedShapeActions\";\n\nexport const getSyncableElements = (\n  elements: readonly ExcalidrawElement[], // There are places in Excalidraw where synthetic invisibly small elements are added and removed.\n) =>\n  // It's probably best to keep those local otherwise there might be a race condition that\n  // gets the app into an invalid state. I've never seen it happen but I'm worried about it :)\n  elements.filter((el) => el.isDeleted || !isInvisiblySmallElement(el));\n\nexport const getElementMap = (elements: readonly ExcalidrawElement[]) =>\n  elements.reduce(\n    (acc: { [key: string]: ExcalidrawElement }, element: ExcalidrawElement) => {\n      acc[element.id] = element;\n      return acc;\n    },\n    {},\n  );\n\nexport const getDrawingVersion = (elements: readonly ExcalidrawElement[]) =>\n  elements.reduce((acc, el) => acc + el.version, 0);\n\nexport const getNonDeletedElements = (elements: readonly ExcalidrawElement[]) =>\n  elements.filter(\n    (element) => !element.isDeleted,\n  ) as readonly NonDeletedExcalidrawElement[];\n\nexport const isNonDeletedElement = <T extends ExcalidrawElement>(\n  element: T,\n): element is NonDeleted<T> => !element.isDeleted;\n","export const isDarwin = /Mac|iPod|iPhone|iPad/.test(\n  typeof window !== \"undefined\" ? window.navigator.platform : \"\",\n);\n\nexport const KEYS = {\n  ARROW_LEFT: \"ArrowLeft\",\n  ARROW_RIGHT: \"ArrowRight\",\n  ARROW_DOWN: \"ArrowDown\",\n  ARROW_UP: \"ArrowUp\",\n  ENTER: \"Enter\",\n  ESCAPE: \"Escape\",\n  DELETE: \"Delete\",\n  BACKSPACE: \"Backspace\",\n  CTRL_OR_CMD: isDarwin ? \"metaKey\" : \"ctrlKey\",\n  TAB: \"Tab\",\n  SPACE: \" \",\n  QUESTION_MARK: \"?\",\n  F_KEY_CODE: 70,\n  ALT_KEY_CODE: 18,\n  Z_KEY_CODE: 90,\n  GRID_KEY_CODE: 222,\n  G_KEY_CODE: 71,\n} as const;\n\nexport type Key = keyof typeof KEYS;\n\nexport const isArrowKey = (keyCode: string) =>\n  keyCode === KEYS.ARROW_LEFT ||\n  keyCode === KEYS.ARROW_RIGHT ||\n  keyCode === KEYS.ARROW_DOWN ||\n  keyCode === KEYS.ARROW_UP;\n\nexport const getResizeCenterPointKey = (event: MouseEvent | KeyboardEvent) =>\n  event.altKey || event.which === KEYS.ALT_KEY_CODE;\n\nexport const getResizeWithSidesSameLengthKey = (event: MouseEvent) =>\n  event.shiftKey;\n\nexport const getRotateWithDiscreteAngleKey = (event: MouseEvent) =>\n  event.shiftKey;\n","import { FontFamily } from \"./element/types\";\n\nexport const DRAGGING_THRESHOLD = 10; // 10px\nexport const LINE_CONFIRM_THRESHOLD = 10; // 10px\nexport const ELEMENT_SHIFT_TRANSLATE_AMOUNT = 5;\nexport const ELEMENT_TRANSLATE_AMOUNT = 1;\nexport const TEXT_TO_CENTER_SNAP_THRESHOLD = 30;\nexport const SHIFT_LOCKING_ANGLE = Math.PI / 12;\nexport const CURSOR_TYPE = {\n  TEXT: \"text\",\n  CROSSHAIR: \"crosshair\",\n  GRABBING: \"grabbing\",\n  POINTER: \"pointer\",\n};\nexport const POINTER_BUTTON = {\n  MAIN: 0,\n  WHEEL: 1,\n  SECONDARY: 2,\n  TOUCH: -1,\n};\n\nexport enum SCENE {\n  INIT = \"SCENE_INIT\",\n  UPDATE = \"SCENE_UPDATE\",\n}\n\nexport enum EVENT {\n  COPY = \"copy\",\n  PASTE = \"paste\",\n  CUT = \"cut\",\n  KEYDOWN = \"keydown\",\n  KEYUP = \"keyup\",\n  MOUSE_MOVE = \"mousemove\",\n  RESIZE = \"resize\",\n  UNLOAD = \"unload\",\n  BLUR = \"blur\",\n  DRAG_OVER = \"dragover\",\n  DROP = \"drop\",\n  GESTURE_END = \"gestureend\",\n  BEFORE_UNLOAD = \"beforeunload\",\n  GESTURE_START = \"gesturestart\",\n  GESTURE_CHANGE = \"gesturechange\",\n  POINTER_MOVE = \"pointermove\",\n  POINTER_UP = \"pointerup\",\n  STATE_CHANGE = \"statechange\",\n  WHEEL = \"wheel\",\n  TOUCH_START = \"touchstart\",\n  TOUCH_END = \"touchend\",\n}\n\nexport const ENV = {\n  TEST: \"test\",\n  DEVELOPMENT: \"development\",\n};\n\nexport const BROADCAST = {\n  SERVER_VOLATILE: \"server-volatile-broadcast\",\n  SERVER: \"server-broadcast\",\n};\n\nexport const CLASSES = {\n  SHAPE_ACTIONS_MENU: \"App-menu__left\",\n};\n\n// 1-based in case we ever do `if(element.fontFamily)`\nexport const FONT_FAMILY = {\n  1: \"Virgil\",\n  2: \"Helvetica\",\n  3: \"Cascadia\",\n} as const;\n\nexport const DEFAULT_FONT_SIZE = 20;\nexport const DEFAULT_FONT_FAMILY: FontFamily = 1;\nexport const DEFAULT_TEXT_ALIGN = \"left\";\nexport const DEFAULT_VERTICAL_ALIGN = \"top\";\n\nexport const CANVAS_ONLY_ACTIONS = [\"selectAll\"];\n\nexport const GRID_SIZE = 20; // TODO make it configurable?\n","import { ExcalidrawElement } from \"./types\";\nimport { invalidateShapeForElement } from \"../renderer/renderElement\";\nimport { globalSceneState } from \"../scene\";\nimport { getSizeFromPoints } from \"../points\";\nimport { randomInteger } from \"../random\";\nimport { Point } from \"../types\";\n\ntype ElementUpdate<TElement extends ExcalidrawElement> = Omit<\n  Partial<TElement>,\n  \"id\" | \"seed\" | \"version\" | \"versionNonce\"\n>;\n\n// This function tracks updates of text elements for the purposes for collaboration.\n// The version is used to compare updates when more than one user is working in\n// the same drawing. Note: this will trigger the component to update. Make sure you\n// are calling it either from a React event handler or within unstable_batchedUpdates().\nexport const mutateElement = <TElement extends Mutable<ExcalidrawElement>>(\n  element: TElement,\n  updates: ElementUpdate<TElement>,\n) => {\n  let didChange = false;\n\n  // casting to any because can't use `in` operator\n  // (see https://github.com/microsoft/TypeScript/issues/21732)\n  const { points } = updates as any;\n\n  if (typeof points !== \"undefined\") {\n    updates = { ...getSizeFromPoints(points), ...updates };\n  }\n\n  for (const key in updates) {\n    const value = (updates as any)[key];\n    if (typeof value !== \"undefined\") {\n      if (\n        (element as any)[key] === value &&\n        // if object, always update in case its deep prop was mutated\n        (typeof value !== \"object\" || value === null || key === \"groupIds\")\n      ) {\n        continue;\n      }\n\n      if (key === \"points\") {\n        const prevPoints = (element as any)[key];\n        const nextPoints = value;\n        if (prevPoints.length === nextPoints.length) {\n          let didChangePoints = false;\n          let i = prevPoints.length;\n          while (--i) {\n            const prevPoint: Point = prevPoints[i];\n            const nextPoint: Point = nextPoints[i];\n            if (\n              prevPoint[0] !== nextPoint[0] ||\n              prevPoint[1] !== nextPoint[1]\n            ) {\n              didChangePoints = true;\n              break;\n            }\n          }\n          if (!didChangePoints) {\n            continue;\n          }\n        }\n      }\n\n      (element as any)[key] = value;\n      didChange = true;\n    }\n  }\n\n  if (!didChange) {\n    return;\n  }\n\n  if (\n    typeof updates.height !== \"undefined\" ||\n    typeof updates.width !== \"undefined\" ||\n    typeof points !== \"undefined\"\n  ) {\n    invalidateShapeForElement(element);\n  }\n\n  element.version++;\n  element.versionNonce = randomInteger();\n\n  globalSceneState.informMutation();\n};\n\nexport const newElementWith = <TElement extends ExcalidrawElement>(\n  element: TElement,\n  updates: ElementUpdate<TElement>,\n): TElement => ({\n  ...element,\n  ...updates,\n  version: element.version + 1,\n  versionNonce: randomInteger(),\n});\n","import {\n  ExcalidrawElement,\n  ExcalidrawTextElement,\n  ExcalidrawLinearElement,\n} from \"./types\";\n\nexport const isTextElement = (\n  element: ExcalidrawElement | null,\n): element is ExcalidrawTextElement => {\n  return element != null && element.type === \"text\";\n};\n\nexport const isLinearElement = (\n  element?: ExcalidrawElement | null,\n): element is ExcalidrawLinearElement => {\n  return (\n    element != null &&\n    (element.type === \"arrow\" ||\n      element.type === \"line\" ||\n      element.type === \"draw\")\n  );\n};\n\nexport const isExcalidrawElement = (element: any): boolean => {\n  return (\n    element?.type === \"text\" ||\n    element?.type === \"diamond\" ||\n    element?.type === \"rectangle\" ||\n    element?.type === \"ellipse\" ||\n    element?.type === \"arrow\" ||\n    element?.type === \"draw\" ||\n    element?.type === \"line\"\n  );\n};\n","import LanguageDetector from \"i18next-browser-languagedetector\";\n\nimport fallbackLanguageData from \"./locales/en.json\";\nimport percentages from \"./locales/percentages.json\";\n\nconst COMPLETION_THRESHOLD_TO_EXCEED = 85;\n\ninterface Language {\n  lng: string;\n  label: string;\n  data: string;\n  rtl?: boolean;\n}\n\nconst allLanguages: Language[] = [\n  { lng: \"bg-BG\", label: \"Български\", data: \"bg-BG.json\" },\n  { lng: \"de-DE\", label: \"Deutsch\", data: \"de-DE.json\" },\n  { lng: \"es-ES\", label: \"Español\", data: \"es-ES.json\" },\n  { lng: \"ca-ES\", label: \"Catalan\", data: \"ca-ES.json\" },\n  { lng: \"el-GR\", label: \"Ελληνικά\", data: \"el-GR.json\" },\n  { lng: \"fr-FR\", label: \"Français\", data: \"fr-FR.json\" },\n  { lng: \"id-ID\", label: \"Bahasa Indonesia\", data: \"id-ID.json\" },\n  { lng: \"it-IT\", label: \"Italiano\", data: \"it-IT.json\" },\n  { lng: \"hu-HU\", label: \"Magyar\", data: \"hu-HU.json\" },\n  { lng: \"nl-NL\", label: \"Nederlands\", data: \"nl-NL.json\" },\n  { lng: \"nb-NO\", label: \"Norsk bokmål\", data: \"nb-NO.json\" },\n  { lng: \"nn-NO\", label: \"Norsk nynorsk\", data: \"nn-NO.json\" },\n  { lng: \"pl-PL\", label: \"Polski\", data: \"pl-PL.json\" },\n  { lng: \"pt-PT\", label: \"Português\", data: \"pt-PT.json\" },\n  { lng: \"ru-RU\", label: \"Русский\", data: \"ru-RU.json\" },\n  { lng: \"uk-UA\", label: \"Українська\", data: \"uk-UA.json\" },\n  { lng: \"fi-FI\", label: \"Suomi\", data: \"fi-FI.json\" },\n  { lng: \"tr-TR\", label: \"Türkçe\", data: \"tr-TR.json\" },\n  { lng: \"ja-JP\", label: \"日本語\", data: \"ja-JP.json\" },\n  { lng: \"ko-KR\", label: \"한국어\", data: \"ko-KR.json\" },\n  { lng: \"zh-TW\", label: \"繁體中文\", data: \"zh-TW.json\" },\n  { lng: \"zh-CN\", label: \"简体中文\", data: \"zh-CN.json\" },\n  { lng: \"ar-SA\", label: \"العربية\", data: \"ar-SA.json\", rtl: true },\n  { lng: \"he-IL\", label: \"עברית\", data: \"he-IL.json\", rtl: true },\n  { lng: \"hi-IN\", label: \"हिन्दी\", data: \"hi-IN.json\" },\n];\n\nexport const languages: Language[] = [\n  { lng: \"en\", label: \"English\", data: \"en.json\" },\n]\n  .concat(\n    allLanguages.sort((left, right) => (left.label > right.label ? 1 : -1)),\n  )\n  .filter(\n    (lang) =>\n      (percentages as Record<string, number>)[lang.lng] >\n      COMPLETION_THRESHOLD_TO_EXCEED,\n  );\n\nlet currentLanguage = languages[0];\nlet currentLanguageData = {};\nconst fallbackLanguage = languages[0];\n\nexport const setLanguage = async (newLng: string | undefined) => {\n  currentLanguage =\n    languages.find((language) => language.lng === newLng) || fallbackLanguage;\n\n  try {\n    document.documentElement.dir = currentLanguage.rtl ? \"rtl\" : \"ltr\";\n  } catch (e) {}\n\n  currentLanguageData = await import(`./locales/${currentLanguage.data}`);\n\n  languageDetector.cacheUserLanguage(currentLanguage.lng);\n};\n\nexport const setLanguageFirstTime = async () => {\n  const newLng: string | undefined = languageDetector.detect();\n\n  currentLanguage =\n    languages.find((language) => language.lng === newLng) || fallbackLanguage;\n\n  document.documentElement.dir = currentLanguage.rtl ? \"rtl\" : \"ltr\";\n\n  currentLanguageData = await import(`./locales/${currentLanguage.data}`);\n\n  languageDetector.cacheUserLanguage(currentLanguage.lng);\n};\n\nexport const getLanguage = () => currentLanguage;\n\nconst findPartsForData = (data: any, parts: string[]) => {\n  for (var i = 0; i < parts.length; ++i) {\n    const part = parts[i];\n    if (data[part] === undefined) {\n      return undefined;\n    }\n    data = data[part];\n  }\n  if (typeof data !== \"string\") {\n    return undefined;\n  }\n  return data;\n};\n\nexport const t = (path: string, replacement?: { [key: string]: string }) => {\n  const parts = path.split(\".\");\n  let translation =\n    findPartsForData(currentLanguageData, parts) ||\n    findPartsForData(fallbackLanguageData, parts);\n  if (translation === undefined) {\n    throw new Error(`Can't find translation for ${path}`);\n  }\n\n  if (replacement) {\n    for (var key in replacement) {\n      translation = translation.replace(`{{${key}}}`, replacement[key]);\n    }\n  }\n  return translation;\n};\n\nconst languageDetector = new LanguageDetector();\nlanguageDetector.init({\n  languageUtils: {\n    formatLanguageCode: (lng: string) => lng,\n    isWhitelisted: () => true,\n  },\n  checkWhitelist: false,\n});\n","export const getZoomOrigin = (\n  canvas: HTMLCanvasElement | null,\n  scale: number,\n) => {\n  if (canvas === null) {\n    return { x: 0, y: 0 };\n  }\n  const context = canvas.getContext(\"2d\");\n  if (context === null) {\n    return { x: 0, y: 0 };\n  }\n\n  const normalizedCanvasWidth = canvas.width / scale;\n  const normalizedCanvasHeight = canvas.height / scale;\n\n  return {\n    x: normalizedCanvasWidth / 2,\n    y: normalizedCanvasHeight / 2,\n  };\n};\n\nexport const getNormalizedZoom = (zoom: number): number => {\n  const normalizedZoom = parseFloat(zoom.toFixed(2));\n  const clampedZoom = Math.max(0.1, Math.min(normalizedZoom, 2));\n  return clampedZoom;\n};\n","import {\n  ExcalidrawElement,\n  NonDeletedExcalidrawElement,\n  NonDeleted,\n} from \"../element/types\";\nimport {\n  getNonDeletedElements,\n  isNonDeletedElement,\n  getElementMap,\n} from \"../element\";\n\nexport interface SceneStateCallback {\n  (): void;\n}\n\nexport interface SceneStateCallbackRemover {\n  (): void;\n}\n\nclass GlobalScene {\n  private callbacks: Set<SceneStateCallback> = new Set();\n\n  private nonDeletedElements: readonly NonDeletedExcalidrawElement[] = [];\n  private elements: readonly ExcalidrawElement[] = [];\n  private elementsMap: {\n    [id: string]: ExcalidrawElement;\n  } = {};\n\n  getElementsIncludingDeleted() {\n    return this.elements;\n  }\n\n  getElements(): readonly NonDeletedExcalidrawElement[] {\n    return this.nonDeletedElements;\n  }\n\n  getElement(id: ExcalidrawElement[\"id\"]): ExcalidrawElement | null {\n    return this.elementsMap[id] || null;\n  }\n\n  getNonDeletedElement(\n    id: ExcalidrawElement[\"id\"],\n  ): NonDeleted<ExcalidrawElement> | null {\n    const element = this.getElement(id);\n    if (element && isNonDeletedElement(element)) {\n      return element;\n    }\n    return null;\n  }\n\n  replaceAllElements(nextElements: readonly ExcalidrawElement[]) {\n    this.elements = nextElements;\n    this.elementsMap = getElementMap(nextElements);\n    this.nonDeletedElements = getNonDeletedElements(this.elements);\n    this.informMutation();\n  }\n\n  informMutation() {\n    for (const callback of Array.from(this.callbacks)) {\n      callback();\n    }\n  }\n\n  addCallback(cb: SceneStateCallback): SceneStateCallbackRemover {\n    if (this.callbacks.has(cb)) {\n      throw new Error();\n    }\n\n    this.callbacks.add(cb);\n\n    return () => {\n      if (!this.callbacks.has(cb)) {\n        throw new Error();\n      }\n      this.callbacks.delete(cb);\n    };\n  }\n}\n\nexport const globalSceneState = new GlobalScene();\n","import {\n  ExcalidrawElement,\n  ExcalidrawTextElement,\n  NonDeletedExcalidrawElement,\n} from \"../element/types\";\nimport { isTextElement, isLinearElement } from \"../element/typeChecks\";\nimport {\n  getDiamondPoints,\n  getArrowPoints,\n  getElementAbsoluteCoords,\n} from \"../element/bounds\";\nimport { RoughCanvas } from \"roughjs/bin/canvas\";\nimport { Drawable, Options } from \"roughjs/bin/core\";\nimport { RoughSVG } from \"roughjs/bin/svg\";\nimport { RoughGenerator } from \"roughjs/bin/generator\";\nimport { SceneState } from \"../scene/types\";\nimport {\n  SVG_NS,\n  distance,\n  getFontString,\n  getFontFamilyString,\n  isRTL,\n} from \"../utils\";\nimport { isPathALoop } from \"../math\";\nimport rough from \"roughjs/bin/rough\";\n\nconst CANVAS_PADDING = 20;\n\nconst DASHARRAY_DASHED = [12, 8];\nconst DASHARRAY_DOTTED = [3, 6];\n\nexport interface ExcalidrawElementWithCanvas {\n  element: ExcalidrawElement | ExcalidrawTextElement;\n  canvas: HTMLCanvasElement;\n  canvasZoom: number;\n  canvasOffsetX: number;\n  canvasOffsetY: number;\n}\n\nconst generateElementCanvas = (\n  element: NonDeletedExcalidrawElement,\n  zoom: number,\n): ExcalidrawElementWithCanvas => {\n  const canvas = document.createElement(\"canvas\");\n  const context = canvas.getContext(\"2d\")!;\n\n  let canvasOffsetX = 0;\n  let canvasOffsetY = 0;\n\n  if (isLinearElement(element)) {\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n    canvas.width =\n      distance(x1, x2) * window.devicePixelRatio * zoom + CANVAS_PADDING * 2;\n    canvas.height =\n      distance(y1, y2) * window.devicePixelRatio * zoom + CANVAS_PADDING * 2;\n\n    canvasOffsetX =\n      element.x > x1\n        ? Math.floor(distance(element.x, x1)) * window.devicePixelRatio\n        : 0;\n    canvasOffsetY =\n      element.y > y1\n        ? Math.floor(distance(element.y, y1)) * window.devicePixelRatio\n        : 0;\n    context.translate(canvasOffsetX * zoom, canvasOffsetY * zoom);\n  } else {\n    canvas.width =\n      element.width * window.devicePixelRatio * zoom + CANVAS_PADDING * 2;\n    canvas.height =\n      element.height * window.devicePixelRatio * zoom + CANVAS_PADDING * 2;\n  }\n\n  context.translate(CANVAS_PADDING, CANVAS_PADDING);\n  context.scale(window.devicePixelRatio * zoom, window.devicePixelRatio * zoom);\n\n  const rc = rough.canvas(canvas);\n  drawElementOnCanvas(element, rc, context);\n  context.translate(-CANVAS_PADDING, -CANVAS_PADDING);\n  context.scale(\n    1 / (window.devicePixelRatio * zoom),\n    1 / (window.devicePixelRatio * zoom),\n  );\n  return { element, canvas, canvasZoom: zoom, canvasOffsetX, canvasOffsetY };\n};\n\nconst drawElementOnCanvas = (\n  element: NonDeletedExcalidrawElement,\n  rc: RoughCanvas,\n  context: CanvasRenderingContext2D,\n) => {\n  context.globalAlpha = element.opacity / 100;\n  switch (element.type) {\n    case \"rectangle\":\n    case \"diamond\":\n    case \"ellipse\": {\n      rc.draw(getShapeForElement(element) as Drawable);\n      break;\n    }\n    case \"arrow\":\n    case \"draw\":\n    case \"line\": {\n      (getShapeForElement(element) as Drawable[]).forEach((shape) => {\n        rc.draw(shape);\n      });\n      break;\n    }\n    default: {\n      if (isTextElement(element)) {\n        const rtl = isRTL(element.text);\n        const shouldTemporarilyAttach = rtl && !context.canvas.isConnected;\n        if (shouldTemporarilyAttach) {\n          // to correctly render RTL text mixed with LTR, we have to append it\n          //  to the DOM\n          document.body.appendChild(context.canvas);\n        }\n        context.canvas.setAttribute(\"dir\", rtl ? \"rtl\" : \"ltr\");\n        const font = context.font;\n        context.font = getFontString(element);\n        const fillStyle = context.fillStyle;\n        context.fillStyle = element.strokeColor;\n        const textAlign = context.textAlign;\n        context.textAlign = element.textAlign as CanvasTextAlign;\n\n        // Canvas does not support multiline text by default\n        const lines = element.text.replace(/\\r\\n?/g, \"\\n\").split(\"\\n\");\n        const lineHeight = element.height / lines.length;\n        const verticalOffset = element.height - element.baseline;\n        const horizontalOffset =\n          element.textAlign === \"center\"\n            ? element.width / 2\n            : element.textAlign === \"right\"\n            ? element.width\n            : 0;\n        for (let i = 0; i < lines.length; i++) {\n          context.fillText(\n            lines[i],\n            horizontalOffset,\n            (i + 1) * lineHeight - verticalOffset,\n          );\n        }\n        context.fillStyle = fillStyle;\n        context.font = font;\n        context.textAlign = textAlign;\n        if (shouldTemporarilyAttach) {\n          context.canvas.remove();\n        }\n      } else {\n        throw new Error(`Unimplemented type ${element.type}`);\n      }\n    }\n  }\n  context.globalAlpha = 1;\n};\n\nconst elementWithCanvasCache = new WeakMap<\n  ExcalidrawElement,\n  ExcalidrawElementWithCanvas\n>();\n\nconst shapeCache = new WeakMap<\n  ExcalidrawElement,\n  Drawable | Drawable[] | null\n>();\n\nexport const getShapeForElement = (element: ExcalidrawElement) =>\n  shapeCache.get(element);\n\nexport const invalidateShapeForElement = (element: ExcalidrawElement) =>\n  shapeCache.delete(element);\n\nexport const generateRoughOptions = (element: ExcalidrawElement): Options => {\n  const options: Options = {\n    seed: element.seed,\n    strokeLineDash:\n      element.strokeStyle === \"dashed\"\n        ? DASHARRAY_DASHED\n        : element.strokeStyle === \"dotted\"\n        ? DASHARRAY_DOTTED\n        : undefined,\n    // for non-solid strokes, disable multiStroke because it tends to make\n    //  dashes/dots overlay each other\n    disableMultiStroke: element.strokeStyle !== \"solid\",\n    // for non-solid strokes, increase the width a bit to make it visually\n    //  similar to solid strokes, because we're also disabling multiStroke\n    strokeWidth:\n      element.strokeStyle !== \"solid\"\n        ? element.strokeWidth + 0.5\n        : element.strokeWidth,\n    // when increasing strokeWidth, we must explicitly set fillWeight and\n    //  hachureGap because if not specified, roughjs uses strokeWidth to\n    //  calculate them (and we don't want the fills to be modified)\n    fillWeight: element.strokeWidth / 2,\n    hachureGap: element.strokeWidth * 4,\n    roughness: element.roughness,\n    stroke: element.strokeColor,\n  };\n\n  switch (element.type) {\n    case \"rectangle\":\n    case \"diamond\":\n    case \"ellipse\": {\n      options.fillStyle = element.fillStyle;\n      options.fill =\n        element.backgroundColor === \"transparent\"\n          ? undefined\n          : element.backgroundColor;\n      if (element.type === \"ellipse\") {\n        options.curveFitting = 1;\n      }\n      return options;\n    }\n    case \"line\":\n    case \"draw\": {\n      // If shape is a line and is a closed shape,\n      // fill the shape if a color is set.\n      if (isPathALoop(element.points)) {\n        options.fillStyle = element.fillStyle;\n        options.fill =\n          element.backgroundColor === \"transparent\"\n            ? undefined\n            : element.backgroundColor;\n      }\n      return options;\n    }\n    case \"arrow\":\n      return options;\n    default: {\n      throw new Error(`Unimplemented type ${element.type}`);\n    }\n  }\n};\n\nconst generateElementShape = (\n  element: NonDeletedExcalidrawElement,\n  generator: RoughGenerator,\n) => {\n  let shape = shapeCache.get(element) || null;\n  if (!shape) {\n    elementWithCanvasCache.delete(element);\n\n    switch (element.type) {\n      case \"rectangle\":\n        shape = generator.rectangle(\n          0,\n          0,\n          element.width,\n          element.height,\n          generateRoughOptions(element),\n        );\n\n        break;\n      case \"diamond\": {\n        const [\n          topX,\n          topY,\n          rightX,\n          rightY,\n          bottomX,\n          bottomY,\n          leftX,\n          leftY,\n        ] = getDiamondPoints(element);\n        shape = generator.polygon(\n          [\n            [topX, topY],\n            [rightX, rightY],\n            [bottomX, bottomY],\n            [leftX, leftY],\n          ],\n          generateRoughOptions(element),\n        );\n        break;\n      }\n      case \"ellipse\":\n        shape = generator.ellipse(\n          element.width / 2,\n          element.height / 2,\n          element.width,\n          element.height,\n          generateRoughOptions(element),\n        );\n        break;\n      case \"line\":\n      case \"draw\":\n      case \"arrow\": {\n        const options = generateRoughOptions(element);\n\n        // points array can be empty in the beginning, so it is important to add\n        // initial position to it\n        const points = element.points.length ? element.points : [[0, 0]];\n\n        // curve is always the first element\n        // this simplifies finding the curve for an element\n        shape = [generator.curve(points as [number, number][], options)];\n\n        // add lines only in arrow\n        if (element.type === \"arrow\") {\n          const [x2, y2, x3, y3, x4, y4] = getArrowPoints(element, shape);\n          // for dotted arrows caps, reduce gap to make it more legible\n          if (element.strokeStyle === \"dotted\") {\n            options.strokeLineDash = [3, 4];\n            // for solid/dashed, keep solid arrow cap\n          } else {\n            delete options.strokeLineDash;\n          }\n          shape.push(\n            ...[\n              generator.line(x3, y3, x2, y2, options),\n              generator.line(x4, y4, x2, y2, options),\n            ],\n          );\n        }\n        break;\n      }\n      case \"text\": {\n        // just to ensure we don't regenerate element.canvas on rerenders\n        shape = [];\n        break;\n      }\n    }\n    shapeCache.set(element, shape);\n  }\n};\n\nconst generateElementWithCanvas = (\n  element: NonDeletedExcalidrawElement,\n  sceneState?: SceneState,\n) => {\n  const zoom = sceneState ? sceneState.zoom : 1;\n  const prevElementWithCanvas = elementWithCanvasCache.get(element);\n  const shouldRegenerateBecauseZoom =\n    prevElementWithCanvas &&\n    prevElementWithCanvas.canvasZoom !== zoom &&\n    !sceneState?.shouldCacheIgnoreZoom;\n  if (!prevElementWithCanvas || shouldRegenerateBecauseZoom) {\n    const elementWithCanvas = generateElementCanvas(element, zoom);\n    elementWithCanvasCache.set(element, elementWithCanvas);\n    return elementWithCanvas;\n  }\n  return prevElementWithCanvas;\n};\n\nconst drawElementFromCanvas = (\n  elementWithCanvas: ExcalidrawElementWithCanvas,\n  rc: RoughCanvas,\n  context: CanvasRenderingContext2D,\n  sceneState: SceneState,\n) => {\n  const element = elementWithCanvas.element;\n  const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n  const cx = ((x1 + x2) / 2 + sceneState.scrollX) * window.devicePixelRatio;\n  const cy = ((y1 + y2) / 2 + sceneState.scrollY) * window.devicePixelRatio;\n  context.scale(1 / window.devicePixelRatio, 1 / window.devicePixelRatio);\n  context.translate(cx, cy);\n  context.rotate(element.angle);\n  context.drawImage(\n    elementWithCanvas.canvas!,\n    (-(x2 - x1) / 2) * window.devicePixelRatio -\n      CANVAS_PADDING / elementWithCanvas.canvasZoom,\n    (-(y2 - y1) / 2) * window.devicePixelRatio -\n      CANVAS_PADDING / elementWithCanvas.canvasZoom,\n    elementWithCanvas.canvas!.width / elementWithCanvas.canvasZoom,\n    elementWithCanvas.canvas!.height / elementWithCanvas.canvasZoom,\n  );\n  context.rotate(-element.angle);\n  context.translate(-cx, -cy);\n  context.scale(window.devicePixelRatio, window.devicePixelRatio);\n\n  // Clear the nested element we appended to the DOM\n};\n\nexport const renderElement = (\n  element: NonDeletedExcalidrawElement,\n  rc: RoughCanvas,\n  context: CanvasRenderingContext2D,\n  renderOptimizations: boolean,\n  sceneState: SceneState,\n) => {\n  const generator = rc.generator;\n  switch (element.type) {\n    case \"selection\": {\n      context.translate(\n        element.x + sceneState.scrollX,\n        element.y + sceneState.scrollY,\n      );\n      const fillStyle = context.fillStyle;\n      context.fillStyle = \"rgba(0, 0, 255, 0.10)\";\n      context.fillRect(0, 0, element.width, element.height);\n      context.fillStyle = fillStyle;\n      context.translate(\n        -element.x - sceneState.scrollX,\n        -element.y - sceneState.scrollY,\n      );\n      break;\n    }\n    case \"rectangle\":\n    case \"diamond\":\n    case \"ellipse\":\n    case \"line\":\n    case \"draw\":\n    case \"arrow\":\n    case \"text\": {\n      generateElementShape(element, generator);\n      if (renderOptimizations) {\n        const elementWithCanvas = generateElementWithCanvas(\n          element,\n          sceneState,\n        );\n        drawElementFromCanvas(elementWithCanvas, rc, context, sceneState);\n      } else {\n        const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n        const cx = (x1 + x2) / 2 + sceneState.scrollX;\n        const cy = (y1 + y2) / 2 + sceneState.scrollY;\n        const shiftX = (x2 - x1) / 2 - (element.x - x1);\n        const shiftY = (y2 - y1) / 2 - (element.y - y1);\n        context.translate(cx, cy);\n        context.rotate(element.angle);\n        context.translate(-shiftX, -shiftY);\n        drawElementOnCanvas(element, rc, context);\n        context.translate(shiftX, shiftY);\n        context.rotate(-element.angle);\n        context.translate(-cx, -cy);\n      }\n      break;\n    }\n    default: {\n      // @ts-ignore\n      throw new Error(`Unimplemented type ${element.type}`);\n    }\n  }\n};\n\nexport const renderElementToSvg = (\n  element: NonDeletedExcalidrawElement,\n  rsvg: RoughSVG,\n  svgRoot: SVGElement,\n  offsetX?: number,\n  offsetY?: number,\n) => {\n  const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n  const cx = (x2 - x1) / 2 - (element.x - x1);\n  const cy = (y2 - y1) / 2 - (element.y - y1);\n  const degree = (180 * element.angle) / Math.PI;\n  const generator = rsvg.generator;\n  switch (element.type) {\n    case \"selection\": {\n      // Since this is used only during editing experience, which is canvas based,\n      // this should not happen\n      throw new Error(\"Selection rendering is not supported for SVG\");\n    }\n    case \"rectangle\":\n    case \"diamond\":\n    case \"ellipse\": {\n      generateElementShape(element, generator);\n      const node = rsvg.draw(getShapeForElement(element) as Drawable);\n      const opacity = element.opacity / 100;\n      if (opacity !== 1) {\n        node.setAttribute(\"stroke-opacity\", `${opacity}`);\n        node.setAttribute(\"fill-opacity\", `${opacity}`);\n      }\n      node.setAttribute(\n        \"transform\",\n        `translate(${offsetX || 0} ${\n          offsetY || 0\n        }) rotate(${degree} ${cx} ${cy})`,\n      );\n      svgRoot.appendChild(node);\n      break;\n    }\n    case \"line\":\n    case \"draw\":\n    case \"arrow\": {\n      generateElementShape(element, generator);\n      const group = svgRoot.ownerDocument!.createElementNS(SVG_NS, \"g\");\n      const opacity = element.opacity / 100;\n      (getShapeForElement(element) as Drawable[]).forEach((shape) => {\n        const node = rsvg.draw(shape);\n        if (opacity !== 1) {\n          node.setAttribute(\"stroke-opacity\", `${opacity}`);\n          node.setAttribute(\"fill-opacity\", `${opacity}`);\n        }\n        node.setAttribute(\n          \"transform\",\n          `translate(${offsetX || 0} ${\n            offsetY || 0\n          }) rotate(${degree} ${cx} ${cy})`,\n        );\n        if (\n          (element.type === \"line\" || element.type === \"draw\") &&\n          isPathALoop(element.points) &&\n          element.backgroundColor !== \"transparent\"\n        ) {\n          node.setAttribute(\"fill-rule\", \"evenodd\");\n        }\n        group.appendChild(node);\n      });\n      svgRoot.appendChild(group);\n      break;\n    }\n    default: {\n      if (isTextElement(element)) {\n        const opacity = element.opacity / 100;\n        const node = svgRoot.ownerDocument!.createElementNS(SVG_NS, \"g\");\n        if (opacity !== 1) {\n          node.setAttribute(\"stroke-opacity\", `${opacity}`);\n          node.setAttribute(\"fill-opacity\", `${opacity}`);\n        }\n        node.setAttribute(\n          \"transform\",\n          `translate(${offsetX || 0} ${\n            offsetY || 0\n          }) rotate(${degree} ${cx} ${cy})`,\n        );\n        const lines = element.text.replace(/\\r\\n?/g, \"\\n\").split(\"\\n\");\n        const lineHeight = element.height / lines.length;\n        const verticalOffset = element.height - element.baseline;\n        const horizontalOffset =\n          element.textAlign === \"center\"\n            ? element.width / 2\n            : element.textAlign === \"right\"\n            ? element.width\n            : 0;\n        const direction = isRTL(element.text) ? \"rtl\" : \"ltr\";\n        const textAnchor =\n          element.textAlign === \"center\"\n            ? \"middle\"\n            : element.textAlign === \"right\" || direction === \"rtl\"\n            ? \"end\"\n            : \"start\";\n        for (let i = 0; i < lines.length; i++) {\n          const text = svgRoot.ownerDocument!.createElementNS(SVG_NS, \"text\");\n          text.textContent = lines[i];\n          text.setAttribute(\"x\", `${horizontalOffset}`);\n          text.setAttribute(\"y\", `${(i + 1) * lineHeight - verticalOffset}`);\n          text.setAttribute(\"font-family\", getFontFamilyString(element));\n          text.setAttribute(\"font-size\", `${element.fontSize}px`);\n          text.setAttribute(\"fill\", element.strokeColor);\n          text.setAttribute(\"text-anchor\", textAnchor);\n          text.setAttribute(\"style\", \"white-space: pre;\");\n          text.setAttribute(\"direction\", direction);\n          node.appendChild(text);\n        }\n        svgRoot.appendChild(node);\n      } else {\n        // @ts-ignore\n        throw new Error(`Unimplemented type ${element.type}`);\n      }\n    }\n  }\n};\n","import { Random } from \"roughjs/bin/math\";\nimport nanoid from \"nanoid\";\n\nlet random = new Random(Date.now());\nlet testIdBase = 0;\n\nexport const randomInteger = () => Math.floor(random.next() * 2 ** 31);\n\nexport const reseed = (seed: number) => {\n  random = new Random(seed);\n  testIdBase = 0;\n};\n\nexport const randomId = () =>\n  process.env.NODE_ENV === \"test\" ? `id${testIdBase++}` : nanoid();\n","import {\n  ExcalidrawElement,\n  NonDeletedExcalidrawElement,\n} from \"../element/types\";\nimport { getElementAbsoluteCoords, getElementBounds } from \"../element\";\nimport { AppState } from \"../types\";\n\nexport const getElementsWithinSelection = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  selection: NonDeletedExcalidrawElement,\n) => {\n  const [\n    selectionX1,\n    selectionY1,\n    selectionX2,\n    selectionY2,\n  ] = getElementAbsoluteCoords(selection);\n  return elements.filter((element) => {\n    const [elementX1, elementY1, elementX2, elementY2] = getElementBounds(\n      element,\n    );\n\n    return (\n      element.type !== \"selection\" &&\n      selectionX1 <= elementX1 &&\n      selectionY1 <= elementY1 &&\n      selectionX2 >= elementX2 &&\n      selectionY2 >= elementY2\n    );\n  });\n};\n\nexport const isSomeElementSelected = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  appState: AppState,\n): boolean => {\n  return elements.some((element) => appState.selectedElementIds[element.id]);\n};\n\n/**\n * Returns common attribute (picked by `getAttribute` callback) of selected\n *  elements. If elements don't share the same value, returns `null`.\n */\nexport const getCommonAttributeOfSelectedElements = <T>(\n  elements: readonly NonDeletedExcalidrawElement[],\n  appState: AppState,\n  getAttribute: (element: ExcalidrawElement) => T,\n): T | null => {\n  const attributes = Array.from(\n    new Set(\n      getSelectedElements(elements, appState).map((element) =>\n        getAttribute(element),\n      ),\n    ),\n  );\n  return attributes.length === 1 ? attributes[0] : null;\n};\n\nexport const getSelectedElements = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  appState: AppState,\n) => {\n  return elements.filter((element) => appState.selectedElementIds[element.id]);\n};\n\nexport const getTargetElement = (\n  elements: readonly NonDeletedExcalidrawElement[],\n  appState: AppState,\n) => {\n  return appState.editingElement\n    ? [appState.editingElement]\n    : getSelectedElements(elements, appState);\n};\n","import { Point } from \"./types\";\n\nexport const getSizeFromPoints = (points: readonly Point[]) => {\n  const xs = points.map((point) => point[0]);\n  const ys = points.map((point) => point[1]);\n  return {\n    width: Math.max(...xs) - Math.min(...xs),\n    height: Math.max(...ys) - Math.min(...ys),\n  };\n};\nexport const rescalePoints = (\n  dimension: 0 | 1,\n  nextDimensionSize: number,\n  prevPoints: readonly Point[],\n): Point[] => {\n  const prevDimValues = prevPoints.map((point) => point[dimension]);\n  const prevMaxDimension = Math.max(...prevDimValues);\n  const prevMinDimension = Math.min(...prevDimValues);\n  const prevDimensionSize = prevMaxDimension - prevMinDimension;\n\n  const dimensionScaleFactor =\n    prevDimensionSize === 0 ? 1 : nextDimensionSize / prevDimensionSize;\n\n  let nextMinDimension = Infinity;\n\n  const scaledPoints = prevPoints.map(\n    (prevPoint) =>\n      prevPoint.map((value, currentDimension) => {\n        if (currentDimension !== dimension) {\n          return value;\n        }\n        const scaledValue = value * dimensionScaleFactor;\n        nextMinDimension = Math.min(scaledValue, nextMinDimension);\n        return scaledValue;\n      }) as [number, number],\n  );\n\n  if (scaledPoints.length === 2) {\n    // we don't tranlate two-point lines\n    return scaledPoints;\n  }\n\n  const translation = prevMinDimension - nextMinDimension;\n\n  const nextPoints = scaledPoints.map(\n    (scaledPoint) =>\n      scaledPoint.map((value, currentDimension) => {\n        return currentDimension === dimension ? value + translation : value;\n      }) as [number, number],\n  );\n\n  return nextPoints;\n};\n","import { AppState, FlooredNumber } from \"../types\";\nimport { ExcalidrawElement } from \"../element/types\";\nimport { getCommonBounds, getClosestElementBounds } from \"../element\";\n\nimport {\n  sceneCoordsToViewportCoords,\n  viewportCoordsToSceneCoords,\n} from \"../utils\";\n\nexport const normalizeScroll = (pos: number) =>\n  Math.floor(pos) as FlooredNumber;\n\nfunction isOutsideViewPort(\n  appState: AppState,\n  canvas: HTMLCanvasElement | null,\n  cords: Array<number>,\n) {\n  const [x1, y1, x2, y2] = cords;\n  const { x: viewportX1, y: viewportY1 } = sceneCoordsToViewportCoords(\n    { sceneX: x1, sceneY: y1 },\n    appState,\n    canvas,\n    window.devicePixelRatio,\n  );\n  const { x: viewportX2, y: viewportY2 } = sceneCoordsToViewportCoords(\n    { sceneX: x2, sceneY: y2 },\n    appState,\n    canvas,\n    window.devicePixelRatio,\n  );\n  return (\n    viewportX2 - viewportX1 > window.innerWidth ||\n    viewportY2 - viewportY1 > window.innerHeight\n  );\n}\n\nexport const calculateScrollCenter = (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n  canvas: HTMLCanvasElement | null,\n): { scrollX: FlooredNumber; scrollY: FlooredNumber } => {\n  if (!elements.length) {\n    return {\n      scrollX: normalizeScroll(0),\n      scrollY: normalizeScroll(0),\n    };\n  }\n  const scale = window.devicePixelRatio;\n  let [x1, y1, x2, y2] = getCommonBounds(elements);\n  if (isOutsideViewPort(appState, canvas, [x1, y1, x2, y2])) {\n    [x1, y1, x2, y2] = getClosestElementBounds(\n      elements,\n      viewportCoordsToSceneCoords(\n        { clientX: appState.scrollX, clientY: appState.scrollY },\n        appState,\n        canvas,\n        scale,\n      ),\n    );\n  }\n\n  const centerX = (x1 + x2) / 2;\n  const centerY = (y1 + y2) / 2;\n\n  return {\n    scrollX: normalizeScroll(window.innerWidth / 2 - centerX),\n    scrollY: normalizeScroll(window.innerHeight / 2 - centerY),\n  };\n};\n","import { ExcalidrawElement } from \"../element/types\";\nimport { getCommonBounds } from \"../element\";\nimport { FlooredNumber } from \"../types\";\nimport { ScrollBars } from \"./types\";\nimport { getGlobalCSSVariable } from \"../utils\";\nimport { getLanguage } from \"../i18n\";\n\nexport const SCROLLBAR_MARGIN = 4;\nexport const SCROLLBAR_WIDTH = 6;\nexport const SCROLLBAR_COLOR = \"rgba(0,0,0,0.3)\";\n\nexport const getScrollBars = (\n  elements: readonly ExcalidrawElement[],\n  viewportWidth: number,\n  viewportHeight: number,\n  {\n    scrollX,\n    scrollY,\n    zoom,\n  }: {\n    scrollX: FlooredNumber;\n    scrollY: FlooredNumber;\n    zoom: number;\n  },\n): ScrollBars => {\n  // This is the bounding box of all the elements\n  const [\n    elementsMinX,\n    elementsMinY,\n    elementsMaxX,\n    elementsMaxY,\n  ] = getCommonBounds(elements);\n\n  // Apply zoom\n  const viewportWidthWithZoom = viewportWidth / zoom;\n  const viewportHeightWithZoom = viewportHeight / zoom;\n\n  const viewportWidthDiff = viewportWidth - viewportWidthWithZoom;\n  const viewportHeightDiff = viewportHeight - viewportHeightWithZoom;\n\n  const safeArea = {\n    top: parseInt(getGlobalCSSVariable(\"sat\")),\n    bottom: parseInt(getGlobalCSSVariable(\"sab\")),\n    left: parseInt(getGlobalCSSVariable(\"sal\")),\n    right: parseInt(getGlobalCSSVariable(\"sar\")),\n  };\n\n  const isRTL = getLanguage().rtl;\n\n  // The viewport is the rectangle currently visible for the user\n  const viewportMinX = -scrollX + viewportWidthDiff / 2 + safeArea.left;\n  const viewportMinY = -scrollY + viewportHeightDiff / 2 + safeArea.top;\n  const viewportMaxX = viewportMinX + viewportWidthWithZoom - safeArea.right;\n  const viewportMaxY = viewportMinY + viewportHeightWithZoom - safeArea.bottom;\n\n  // The scene is the bounding box of both the elements and viewport\n  const sceneMinX = Math.min(elementsMinX, viewportMinX);\n  const sceneMinY = Math.min(elementsMinY, viewportMinY);\n  const sceneMaxX = Math.max(elementsMaxX, viewportMaxX);\n  const sceneMaxY = Math.max(elementsMaxY, viewportMaxY);\n\n  // The scrollbar represents where the viewport is in relationship to the scene\n\n  return {\n    horizontal:\n      viewportMinX === sceneMinX && viewportMaxX === sceneMaxX\n        ? null\n        : {\n            x:\n              Math.max(safeArea.left, SCROLLBAR_MARGIN) +\n              ((viewportMinX - sceneMinX) / (sceneMaxX - sceneMinX)) *\n                viewportWidth,\n            y:\n              viewportHeight -\n              SCROLLBAR_WIDTH -\n              Math.max(SCROLLBAR_MARGIN, safeArea.bottom),\n            width:\n              ((viewportMaxX - viewportMinX) / (sceneMaxX - sceneMinX)) *\n                viewportWidth -\n              Math.max(SCROLLBAR_MARGIN * 2, safeArea.left + safeArea.right),\n            height: SCROLLBAR_WIDTH,\n          },\n    vertical:\n      viewportMinY === sceneMinY && viewportMaxY === sceneMaxY\n        ? null\n        : {\n            x: isRTL\n              ? Math.max(safeArea.left, SCROLLBAR_MARGIN)\n              : viewportWidth -\n                SCROLLBAR_WIDTH -\n                Math.max(safeArea.right, SCROLLBAR_MARGIN),\n            y:\n              ((viewportMinY - sceneMinY) / (sceneMaxY - sceneMinY)) *\n                viewportHeight +\n              Math.max(safeArea.top, SCROLLBAR_MARGIN),\n            width: SCROLLBAR_WIDTH,\n            height:\n              ((viewportMaxY - viewportMinY) / (sceneMaxY - sceneMinY)) *\n                viewportHeight -\n              Math.max(SCROLLBAR_MARGIN * 2, safeArea.top + safeArea.bottom),\n          },\n  };\n};\n\nexport const isOverScrollBars = (\n  scrollBars: ScrollBars,\n  x: number,\n  y: number,\n) => {\n  const [isOverHorizontalScrollBar, isOverVerticalScrollBar] = [\n    scrollBars.horizontal,\n    scrollBars.vertical,\n  ].map((scrollBar) => {\n    return (\n      scrollBar &&\n      scrollBar.x <= x &&\n      x <= scrollBar.x + scrollBar.width &&\n      scrollBar.y <= y &&\n      y <= scrollBar.y + scrollBar.height\n    );\n  });\n\n  return {\n    isOverHorizontalScrollBar,\n    isOverVerticalScrollBar,\n  };\n};\n","import { GroupId, ExcalidrawElement, NonDeleted } from \"./element/types\";\nimport { AppState } from \"./types\";\nimport { getSelectedElements } from \"./scene\";\n\nexport function selectGroup(\n  groupId: GroupId,\n  appState: AppState,\n  elements: readonly NonDeleted<ExcalidrawElement>[],\n): AppState {\n  const elementsInGroup = elements.filter((element) =>\n    element.groupIds.includes(groupId),\n  );\n\n  if (elementsInGroup.length < 2) {\n    if (\n      appState.selectedGroupIds[groupId] ||\n      appState.editingGroupId === groupId\n    ) {\n      return {\n        ...appState,\n        selectedGroupIds: { ...appState.selectedGroupIds, [groupId]: false },\n        editingGroupId: null,\n      };\n    }\n    return appState;\n  }\n\n  return {\n    ...appState,\n    selectedGroupIds: { ...appState.selectedGroupIds, [groupId]: true },\n    selectedElementIds: {\n      ...appState.selectedElementIds,\n      ...Object.fromEntries(\n        elementsInGroup.map((element) => [element.id, true]),\n      ),\n    },\n  };\n}\n\n/**\n * If the element's group is selected, don't render an individual\n * selection border around it.\n */\nexport function isSelectedViaGroup(\n  appState: AppState,\n  element: ExcalidrawElement,\n) {\n  return !!element.groupIds\n    .filter((groupId) => groupId !== appState.editingGroupId)\n    .find((groupId) => appState.selectedGroupIds[groupId]);\n}\n\nexport function getSelectedGroupIds(appState: AppState): GroupId[] {\n  return Object.entries(appState.selectedGroupIds)\n    .filter(([groupId, isSelected]) => isSelected)\n    .map(([groupId, isSelected]) => groupId);\n}\n\n/**\n * When you select an element, you often want to actually select the whole group it's in, unless\n * you're currently editing that group.\n */\nexport function selectGroupsForSelectedElements(\n  appState: AppState,\n  elements: readonly NonDeleted<ExcalidrawElement>[],\n): AppState {\n  let nextAppState = { ...appState };\n\n  const selectedElements = getSelectedElements(elements, appState);\n\n  for (const selectedElement of selectedElements) {\n    let groupIds = selectedElement.groupIds;\n    if (appState.editingGroupId) {\n      // handle the case where a group is nested within a group\n      const indexOfEditingGroup = groupIds.indexOf(appState.editingGroupId);\n      if (indexOfEditingGroup > -1) {\n        groupIds = groupIds.slice(0, indexOfEditingGroup);\n      }\n    }\n    if (groupIds.length > 0) {\n      const groupId = groupIds[groupIds.length - 1];\n      nextAppState = selectGroup(groupId, nextAppState, elements);\n    }\n  }\n\n  return nextAppState;\n}\n\nexport function isElementInGroup(element: ExcalidrawElement, groupId: string) {\n  return element.groupIds.includes(groupId);\n}\n\nexport function getElementsInGroup(\n  elements: readonly ExcalidrawElement[],\n  groupId: string,\n) {\n  return elements.filter((element) => isElementInGroup(element, groupId));\n}\n\nexport function getSelectedGroupIdForElement(\n  element: ExcalidrawElement,\n  selectedGroupIds: { [groupId: string]: boolean },\n) {\n  return element.groupIds.find((groupId) => selectedGroupIds[groupId]);\n}\n\nexport function getNewGroupIdsForDuplication(\n  groupIds: ExcalidrawElement[\"groupIds\"],\n  editingGroupId: AppState[\"editingGroupId\"],\n  mapper: (groupId: GroupId) => GroupId,\n) {\n  const copy = [...groupIds];\n  const positionOfEditingGroupId = editingGroupId\n    ? groupIds.indexOf(editingGroupId)\n    : -1;\n  const endIndex =\n    positionOfEditingGroupId > -1 ? positionOfEditingGroupId : groupIds.length;\n  for (let i = 0; i < endIndex; i++) {\n    copy[i] = mapper(copy[i]);\n  }\n\n  return copy;\n}\n\nexport function addToGroup(\n  prevGroupIds: ExcalidrawElement[\"groupIds\"],\n  newGroupId: GroupId,\n  editingGroupId: AppState[\"editingGroupId\"],\n) {\n  // insert before the editingGroupId, or push to the end.\n  const groupIds = [...prevGroupIds];\n  const positionOfEditingGroupId = editingGroupId\n    ? groupIds.indexOf(editingGroupId)\n    : -1;\n  const positionToInsert =\n    positionOfEditingGroupId > -1 ? positionOfEditingGroupId : groupIds.length;\n  groupIds.splice(positionToInsert, 0, newGroupId);\n  return groupIds;\n}\n\nexport function removeFromSelectedGroups(\n  groupIds: ExcalidrawElement[\"groupIds\"],\n  selectedGroupIds: { [groupId: string]: boolean },\n) {\n  return groupIds.filter((groupId) => !selectedGroupIds[groupId]);\n}\n","var map = {\n\t\"./README.md\": [\n\t\t85,\n\t\t7,\n\t\t30\n\t],\n\t\"./ar-SA\": [\n\t\t46,\n\t\t3,\n\t\t0\n\t],\n\t\"./ar-SA.json\": [\n\t\t46,\n\t\t3,\n\t\t0\n\t],\n\t\"./bg-BG\": [\n\t\t47,\n\t\t3,\n\t\t1\n\t],\n\t\"./bg-BG.json\": [\n\t\t47,\n\t\t3,\n\t\t1\n\t],\n\t\"./ca-ES\": [\n\t\t48,\n\t\t3,\n\t\t2\n\t],\n\t\"./ca-ES.json\": [\n\t\t48,\n\t\t3,\n\t\t2\n\t],\n\t\"./de-DE\": [\n\t\t49,\n\t\t3,\n\t\t3\n\t],\n\t\"./de-DE.json\": [\n\t\t49,\n\t\t3,\n\t\t3\n\t],\n\t\"./el-GR\": [\n\t\t50,\n\t\t3,\n\t\t4\n\t],\n\t\"./el-GR.json\": [\n\t\t50,\n\t\t3,\n\t\t4\n\t],\n\t\"./en\": [\n\t\t34,\n\t\t3\n\t],\n\t\"./en.json\": [\n\t\t34,\n\t\t3\n\t],\n\t\"./es-ES\": [\n\t\t51,\n\t\t3,\n\t\t5\n\t],\n\t\"./es-ES.json\": [\n\t\t51,\n\t\t3,\n\t\t5\n\t],\n\t\"./fa-IR\": [\n\t\t52,\n\t\t3,\n\t\t6\n\t],\n\t\"./fa-IR.json\": [\n\t\t52,\n\t\t3,\n\t\t6\n\t],\n\t\"./fi-FI\": [\n\t\t53,\n\t\t3,\n\t\t7\n\t],\n\t\"./fi-FI.json\": [\n\t\t53,\n\t\t3,\n\t\t7\n\t],\n\t\"./fr-FR\": [\n\t\t54,\n\t\t3,\n\t\t8\n\t],\n\t\"./fr-FR.json\": [\n\t\t54,\n\t\t3,\n\t\t8\n\t],\n\t\"./he-IL\": [\n\t\t55,\n\t\t3,\n\t\t9\n\t],\n\t\"./he-IL.json\": [\n\t\t55,\n\t\t3,\n\t\t9\n\t],\n\t\"./hi-IN\": [\n\t\t56,\n\t\t3,\n\t\t10\n\t],\n\t\"./hi-IN.json\": [\n\t\t56,\n\t\t3,\n\t\t10\n\t],\n\t\"./hu-HU\": [\n\t\t57,\n\t\t3,\n\t\t11\n\t],\n\t\"./hu-HU.json\": [\n\t\t57,\n\t\t3,\n\t\t11\n\t],\n\t\"./id-ID\": [\n\t\t58,\n\t\t3,\n\t\t12\n\t],\n\t\"./id-ID.json\": [\n\t\t58,\n\t\t3,\n\t\t12\n\t],\n\t\"./it-IT\": [\n\t\t59,\n\t\t3,\n\t\t13\n\t],\n\t\"./it-IT.json\": [\n\t\t59,\n\t\t3,\n\t\t13\n\t],\n\t\"./ja-JP\": [\n\t\t60,\n\t\t3,\n\t\t14\n\t],\n\t\"./ja-JP.json\": [\n\t\t60,\n\t\t3,\n\t\t14\n\t],\n\t\"./ko-KR\": [\n\t\t61,\n\t\t3,\n\t\t15\n\t],\n\t\"./ko-KR.json\": [\n\t\t61,\n\t\t3,\n\t\t15\n\t],\n\t\"./nb-NO\": [\n\t\t62,\n\t\t3,\n\t\t16\n\t],\n\t\"./nb-NO.json\": [\n\t\t62,\n\t\t3,\n\t\t16\n\t],\n\t\"./nl-NL\": [\n\t\t63,\n\t\t3,\n\t\t17\n\t],\n\t\"./nl-NL.json\": [\n\t\t63,\n\t\t3,\n\t\t17\n\t],\n\t\"./nn-NO\": [\n\t\t64,\n\t\t3,\n\t\t18\n\t],\n\t\"./nn-NO.json\": [\n\t\t64,\n\t\t3,\n\t\t18\n\t],\n\t\"./percentages\": [\n\t\t35,\n\t\t3\n\t],\n\t\"./percentages.json\": [\n\t\t35,\n\t\t3\n\t],\n\t\"./pl-PL\": [\n\t\t65,\n\t\t3,\n\t\t19\n\t],\n\t\"./pl-PL.json\": [\n\t\t65,\n\t\t3,\n\t\t19\n\t],\n\t\"./pt-PT\": [\n\t\t66,\n\t\t3,\n\t\t20\n\t],\n\t\"./pt-PT.json\": [\n\t\t66,\n\t\t3,\n\t\t20\n\t],\n\t\"./ru-RU\": [\n\t\t67,\n\t\t3,\n\t\t21\n\t],\n\t\"./ru-RU.json\": [\n\t\t67,\n\t\t3,\n\t\t21\n\t],\n\t\"./sq-AL\": [\n\t\t68,\n\t\t3,\n\t\t22\n\t],\n\t\"./sq-AL.json\": [\n\t\t68,\n\t\t3,\n\t\t22\n\t],\n\t\"./tr-TR\": [\n\t\t69,\n\t\t3,\n\t\t23\n\t],\n\t\"./tr-TR.json\": [\n\t\t69,\n\t\t3,\n\t\t23\n\t],\n\t\"./uk-UA\": [\n\t\t70,\n\t\t3,\n\t\t24\n\t],\n\t\"./uk-UA.json\": [\n\t\t70,\n\t\t3,\n\t\t24\n\t],\n\t\"./zh-CN\": [\n\t\t71,\n\t\t3,\n\t\t25\n\t],\n\t\"./zh-CN.json\": [\n\t\t71,\n\t\t3,\n\t\t25\n\t],\n\t\"./zh-TW\": [\n\t\t72,\n\t\t3,\n\t\t26\n\t],\n\t\"./zh-TW.json\": [\n\t\t72,\n\t\t3,\n\t\t26\n\t]\n};\nfunction webpackAsyncContext(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\treturn Promise.resolve().then(function() {\n\t\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\t\te.code = 'MODULE_NOT_FOUND';\n\t\t\tthrow e;\n\t\t});\n\t}\n\n\tvar ids = map[req], id = ids[0];\n\treturn Promise.all(ids.slice(2).map(__webpack_require__.e)).then(function() {\n\t\treturn __webpack_require__.t(id, ids[1])\n\t});\n}\nwebpackAsyncContext.keys = function webpackAsyncContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackAsyncContext.id = 40;\nmodule.exports = webpackAsyncContext;","import React, { useEffect, useRef } from \"react\";\n\nimport \"./Viewer.css\";\nimport { NonDeletedExcalidrawElement } from \"./excalidraw/src/element/types\";\nimport { getCommonBounds } from \"./excalidraw/src/element/bounds\";\n\ntype Props = {\n  elements: readonly NonDeletedExcalidrawElement[];\n};\n\nconst Viewer: React.FC<Props> = ({ elements }) => {\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n\n  useEffect(() => {\n    if (canvasRef.current) {\n      const canvas = canvasRef.current;\n      const width = canvas.parentElement?.clientWidth || 300;\n      const height = canvas.parentElement?.clientHeight || 300;\n      const worker = new Worker(\"./viewer.worker\", {\n        // https://github.com/GoogleChromeLabs/worker-plugin/issues/43\n        name: \"x\",\n        type: \"module\",\n      });\n      canvas.style.width = `${width}px`;\n      canvas.style.height = `${height}px`;\n      const offscreen = canvas.transferControlToOffscreen();\n      const scale = window.devicePixelRatio;\n      const [minX, minY] = getCommonBounds(elements);\n      const exportPadding = 10;\n      const toolbarHeight = 27;\n      const scrollX = Math.floor(-minX + exportPadding);\n      const scrollY = Math.floor(-minY + exportPadding + toolbarHeight);\n      worker.postMessage(\n        {\n          type: \"init\",\n          offscreen,\n          scale,\n          width,\n          height,\n          scrollX,\n          scrollY,\n          elements,\n        },\n        [offscreen]\n      );\n      let viewAngle = 0;\n      let zoom = 1;\n      let centerX = 0;\n      let centerY = 0;\n      const onWheel = (e: WheelEvent) => {\n        e.preventDefault();\n        if (e.ctrlKey) {\n          zoom -= e.deltaY / 100;\n          zoom = Math.max(0.1, Math.min(2, zoom));\n        } else if (e.shiftKey) {\n          viewAngle += e.deltaY / 1000;\n          viewAngle = Math.max(0, Math.min(Math.PI / 2, viewAngle));\n        } else {\n          centerX += e.deltaX / zoom;\n          centerY -= e.deltaY / zoom;\n        }\n        worker.postMessage({\n          type: \"render\",\n          viewAngle,\n          zoom,\n          centerX,\n          centerY,\n        });\n      };\n      canvas.addEventListener(\"wheel\", onWheel, { passive: false });\n      return () => {\n        worker.terminate();\n        canvas.removeEventListener(\"wheel\", onWheel);\n      };\n    }\n  }, [elements]);\n\n  return (\n    <div className=\"Viewer\">\n      <canvas ref={canvasRef} />\n    </div>\n  );\n};\n\nexport default Viewer;\n","module.exports = __webpack_public_path__ + \"static/js/x.c29cb98c.chunk.worker.js\"","import oc from \"open-color\";\nimport { AppState, FlooredNumber } from \"./types\";\nimport { getDateTime } from \"./utils\";\nimport { t } from \"./i18n\";\nimport {\n  DEFAULT_FONT_SIZE,\n  DEFAULT_FONT_FAMILY,\n  DEFAULT_TEXT_ALIGN,\n} from \"./constants\";\n\nexport const getDefaultAppState = (): AppState => {\n  return {\n    isLoading: false,\n    errorMessage: null,\n    draggingElement: null,\n    resizingElement: null,\n    multiElement: null,\n    editingElement: null,\n    editingLinearElement: null,\n    elementType: \"selection\",\n    elementLocked: false,\n    exportBackground: true,\n    shouldAddWatermark: false,\n    currentItemStrokeColor: oc.black,\n    currentItemBackgroundColor: \"transparent\",\n    currentItemFillStyle: \"hachure\",\n    currentItemStrokeWidth: 1,\n    currentItemStrokeStyle: \"solid\",\n    currentItemRoughness: 1,\n    currentItemOpacity: 100,\n    currentItemFontSize: DEFAULT_FONT_SIZE,\n    currentItemFontFamily: DEFAULT_FONT_FAMILY,\n    currentItemTextAlign: DEFAULT_TEXT_ALIGN,\n    viewBackgroundColor: oc.white,\n    scrollX: 0 as FlooredNumber,\n    scrollY: 0 as FlooredNumber,\n    cursorX: 0,\n    cursorY: 0,\n    cursorButton: \"up\",\n    scrolledOutside: false,\n    name: `${t(\"labels.untitled\")}-${getDateTime()}`,\n    username: \"\",\n    isCollaborating: false,\n    isResizing: false,\n    isRotating: false,\n    selectionElement: null,\n    zoom: 1,\n    openMenu: null,\n    lastPointerDownWith: \"mouse\",\n    selectedElementIds: {},\n    previousSelectedElementIds: {},\n    collaborators: new Map(),\n    shouldCacheIgnoreZoom: false,\n    showShortcutsDialog: false,\n    zenModeEnabled: false,\n    gridSize: null,\n    editingGroupId: null,\n    selectedGroupIds: {},\n  };\n};\n\nexport const clearAppStateForLocalStorage = (appState: AppState) => {\n  const {\n    draggingElement,\n    resizingElement,\n    multiElement,\n    editingElement,\n    selectionElement,\n    isResizing,\n    isRotating,\n    collaborators,\n    isCollaborating,\n    isLoading,\n    errorMessage,\n    showShortcutsDialog,\n    editingLinearElement,\n    ...exportedState\n  } = appState;\n  return exportedState;\n};\n\nexport const cleanAppStateForExport = (appState: AppState) => {\n  return {\n    viewBackgroundColor: appState.viewBackgroundColor,\n    gridSize: appState.gridSize,\n  };\n};\n","import {\n  ExcalidrawElement,\n  FontFamily,\n  ExcalidrawSelectionElement,\n} from \"../element/types\";\nimport { AppState } from \"../types\";\nimport { DataState } from \"./types\";\nimport { isInvisiblySmallElement, getNormalizedDimensions } from \"../element\";\nimport { calculateScrollCenter } from \"../scene\";\nimport { randomId } from \"../random\";\nimport {\n  FONT_FAMILY,\n  DEFAULT_FONT_FAMILY,\n  DEFAULT_TEXT_ALIGN,\n  DEFAULT_VERTICAL_ALIGN,\n} from \"../constants\";\n\nconst getFontFamilyByName = (fontFamilyName: string): FontFamily => {\n  for (const [id, fontFamilyString] of Object.entries(FONT_FAMILY)) {\n    if (fontFamilyString.includes(fontFamilyName)) {\n      return parseInt(id) as FontFamily;\n    }\n  }\n  return DEFAULT_FONT_FAMILY;\n};\n\nfunction migrateElementWithProperties<T extends ExcalidrawElement>(\n  element: T,\n  extra: Omit<T, keyof ExcalidrawElement>,\n): T {\n  const base: Pick<T, keyof ExcalidrawElement> = {\n    type: element.type,\n    // all elements must have version > 0 so getDrawingVersion() will pick up\n    //  newly added elements\n    version: element.version || 1,\n    versionNonce: element.versionNonce ?? 0,\n    isDeleted: false,\n    id: element.id || randomId(),\n    fillStyle: element.fillStyle || \"hachure\",\n    strokeWidth: element.strokeWidth || 1,\n    strokeStyle: element.strokeStyle ?? \"solid\",\n    roughness: element.roughness ?? 1,\n    opacity: element.opacity == null ? 100 : element.opacity,\n    angle: element.angle || 0,\n    x: element.x || 0,\n    y: element.y || 0,\n    strokeColor: element.strokeColor,\n    backgroundColor: element.backgroundColor,\n    width: element.width || 0,\n    height: element.height || 0,\n    seed: element.seed ?? 1,\n    groupIds: element.groupIds || [],\n  };\n\n  return {\n    ...base,\n    ...getNormalizedDimensions(base),\n    ...extra,\n  } as T;\n}\n\nconst migrateElement = (\n  element: Exclude<ExcalidrawElement, ExcalidrawSelectionElement>,\n): typeof element => {\n  switch (element.type) {\n    case \"text\":\n      let fontSize = element.fontSize;\n      let fontFamily = element.fontFamily;\n      if (\"font\" in element) {\n        const [fontPx, _fontFamily]: [\n          string,\n          string,\n        ] = (element as any).font.split(\" \");\n        fontSize = parseInt(fontPx, 10);\n        fontFamily = getFontFamilyByName(_fontFamily);\n      }\n      return migrateElementWithProperties(element, {\n        fontSize,\n        fontFamily,\n        text: element.text ?? \"\",\n        baseline: element.baseline,\n        textAlign: element.textAlign || DEFAULT_TEXT_ALIGN,\n        verticalAlign: element.verticalAlign || DEFAULT_VERTICAL_ALIGN,\n      });\n    case \"draw\":\n    case \"line\":\n    case \"arrow\": {\n      return migrateElementWithProperties(element, {\n        points:\n          // migrate old arrow model to new one\n          !Array.isArray(element.points) || element.points.length < 2\n            ? [\n                [0, 0],\n                [element.width, element.height],\n              ]\n            : element.points,\n      });\n    }\n    // generic elements\n    case \"ellipse\":\n    case \"rectangle\":\n    case \"diamond\":\n      return migrateElementWithProperties(element, {});\n\n    // don't use default case so as to catch a missing an element type case\n    //  (we also don't want to throw, but instead return void so we\n    //   filter out these unsupported elements from the restored array)\n  }\n};\n\nexport const restore = (\n  savedElements: readonly ExcalidrawElement[],\n  savedState: AppState | null,\n  opts?: { scrollToContent: boolean },\n): DataState => {\n  const elements = savedElements.reduce((elements, element) => {\n    // filtering out selection, which is legacy, no longer kept in elements,\n    //  and causing issues if retained\n    if (element.type !== \"selection\" && !isInvisiblySmallElement(element)) {\n      const migratedElement = migrateElement(element);\n      if (migratedElement) {\n        elements.push(migratedElement);\n      }\n    }\n    return elements;\n  }, [] as ExcalidrawElement[]);\n\n  if (opts?.scrollToContent && savedState) {\n    savedState = {\n      ...savedState,\n      ...calculateScrollCenter(elements, savedState, null),\n    };\n  }\n\n  return {\n    elements: elements,\n    appState: savedState,\n  };\n};\n","import { getDefaultAppState } from \"../appState\";\nimport { restore } from \"./restore\";\nimport { t } from \"../i18n\";\n\nexport const loadFromBlob = async (blob: any) => {\n  const updateAppState = (contents: string) => {\n    const defaultAppState = getDefaultAppState();\n    let elements = [];\n    let appState = defaultAppState;\n    try {\n      const data = JSON.parse(contents);\n      if (data.type !== \"excalidraw\") {\n        throw new Error(t(\"alerts.couldNotLoadInvalidFile\"));\n      }\n      elements = data.elements || [];\n      appState = { ...defaultAppState, ...data.appState };\n    } catch {\n      throw new Error(t(\"alerts.couldNotLoadInvalidFile\"));\n    }\n    return { elements, appState };\n  };\n\n  if (blob.handle) {\n    (window as any).handle = blob.handle;\n  }\n  let contents;\n  if (\"text\" in Blob) {\n    contents = await blob.text();\n  } else {\n    contents = await new Promise((resolve) => {\n      const reader = new FileReader();\n      reader.readAsText(blob, \"utf8\");\n      reader.onloadend = () => {\n        if (reader.readyState === FileReader.DONE) {\n          resolve(reader.result as string);\n        }\n      };\n    });\n  }\n\n  const { elements, appState } = updateAppState(contents);\n  return restore(elements, appState, { scrollToContent: true });\n};\n","import { ExcalidrawElement } from \"../element/types\";\nimport { AppState } from \"../types\";\nimport { cleanAppStateForExport } from \"../appState\";\n\nimport { fileOpen, fileSave } from \"browser-nativefs\";\nimport { loadFromBlob } from \"./blob\";\n\nexport const serializeAsJSON = (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n): string =>\n  JSON.stringify(\n    {\n      type: \"excalidraw\",\n      version: 2,\n      source: window.location.origin,\n      elements: elements.filter((element) => !element.isDeleted),\n      appState: cleanAppStateForExport(appState),\n    },\n    null,\n    2,\n  );\n\nexport const saveAsJSON = async (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n  fileHandle: any,\n) => {\n  const serialized = serializeAsJSON(elements, appState);\n  const blob = new Blob([serialized], {\n    type: \"application/json\",\n  });\n  const name = `${appState.name}.excalidraw`;\n  (window as any).handle = await fileSave(\n    blob,\n    {\n      fileName: name,\n      description: \"Excalidraw file\",\n      extensions: [\"excalidraw\"],\n    },\n    fileHandle || null,\n  );\n};\n\nexport const loadFromJSON = async () => {\n  const blob = await fileOpen({\n    description: \"Excalidraw files\",\n    extensions: [\"json\", \"excalidraw\"],\n    mimeTypes: [\"application/json\"],\n  });\n  return loadFromBlob(blob);\n};\n","import React, { useEffect, useState } from \"react\";\n\nimport \"./Toolbar.css\";\nimport {\n  ExcalidrawElement,\n  NonDeletedExcalidrawElement,\n} from \"./excalidraw/src/element/types\";\nimport { loadFromJSON } from \"./excalidraw/src/data/json\";\n\nconst linkRegex = /#json=([0-9]+),?([a-zA-Z0-9_-]*)/;\n\ntype Props = {\n  elements?: readonly NonDeletedExcalidrawElement[];\n  loadData: (data: { elements: readonly ExcalidrawElement[] }) => void;\n};\n\nconst Toolbar: React.FC<Props> = ({ elements, loadData }) => {\n  const [showToolbar, setShowToolbar] = useState(false);\n  const [link, setLink] = useState(\"\");\n\n  useEffect(() => {\n    const hash = window.location.hash.slice(1);\n    const searchParams = new URLSearchParams(hash);\n    if (searchParams.get(\"toolbar\") !== \"no\") {\n      setShowToolbar(true);\n    }\n  }, []);\n\n  if (!showToolbar) {\n    return null;\n  }\n\n  const loadFile = async () => {\n    const data = await loadFromJSON();\n    loadData(data);\n  };\n\n  const loadLink = (event: React.FormEvent<HTMLFormElement>) => {\n    event.preventDefault();\n    const match = linkRegex.exec(link);\n    if (!match) {\n      window.alert(\"Invalid link\");\n      return;\n    }\n    window.location.hash = match[0];\n    window.location.reload();\n  };\n\n  return (\n    <div className=\"Toolbar\">\n      <button type=\"button\" onClick={loadFile} disabled={!!elements}>\n        Load File\n      </button>\n      <span>OR</span>\n      <form onSubmit={loadLink}>\n        <input\n          placeholder=\"Enter shareable link...\"\n          value={link}\n          onChange={(e) => setLink(e.target.value)}\n        />\n        <button type=\"submit\" disabled={!linkRegex.test(link)}>\n          View\n        </button>\n      </form>\n    </div>\n  );\n};\n\nexport default Toolbar;\n","import oc from \"open-color\";\n\nconst shades = (i: number) => [\n  oc.red[i],\n  oc.pink[i],\n  oc.grape[i],\n  oc.violet[i],\n  oc.indigo[i],\n  oc.blue[i],\n  oc.cyan[i],\n  oc.teal[i],\n  oc.green[i],\n  oc.lime[i],\n  oc.yellow[i],\n  oc.orange[i],\n];\n\nexport default {\n  canvasBackground: [oc.white, oc.gray[0], oc.gray[1], ...shades(0)],\n  elementBackground: [\"transparent\", oc.gray[4], oc.gray[6], ...shades(6)],\n  elementStroke: [oc.black, oc.gray[8], oc.gray[7], ...shades(9)],\n};\n","import {\n  NonDeleted,\n  ExcalidrawLinearElement,\n  ExcalidrawElement,\n} from \"./types\";\nimport { distance2d, rotate, isPathALoop } from \"../math\";\nimport { getElementAbsoluteCoords } from \".\";\nimport { getElementPointsCoords } from \"./bounds\";\nimport { Point, AppState } from \"../types\";\nimport { mutateElement } from \"./mutateElement\";\nimport { SceneHistory } from \"../history\";\nimport { globalSceneState } from \"../scene\";\n\nexport class LinearElementEditor {\n  public elementId: ExcalidrawElement[\"id\"];\n  public activePointIndex: number | null;\n  public draggingElementPointIndex: number | null;\n  public lastUncommittedPoint: Point | null;\n\n  constructor(element: NonDeleted<ExcalidrawLinearElement>) {\n    LinearElementEditor.normalizePoints(element);\n\n    this.elementId = element.id;\n    this.activePointIndex = null;\n    this.lastUncommittedPoint = null;\n    this.draggingElementPointIndex = null;\n  }\n\n  // ---------------------------------------------------------------------------\n  // static methods\n  // ---------------------------------------------------------------------------\n\n  static POINT_HANDLE_SIZE = 20;\n\n  static getElement(id: ExcalidrawElement[\"id\"]) {\n    const element = globalSceneState.getNonDeletedElement(id);\n    if (element) {\n      return element as NonDeleted<ExcalidrawLinearElement>;\n    }\n    return null;\n  }\n\n  /** @returns whether point was dragged */\n  static handlePointDragging(\n    appState: AppState,\n    setState: React.Component<any, AppState>[\"setState\"],\n    scenePointerX: number,\n    scenePointerY: number,\n    lastX: number,\n    lastY: number,\n  ): boolean {\n    if (!appState.editingLinearElement) {\n      return false;\n    }\n    const { editingLinearElement } = appState;\n    let { draggingElementPointIndex, elementId } = editingLinearElement;\n\n    const element = LinearElementEditor.getElement(elementId);\n    if (!element) {\n      return false;\n    }\n\n    const clickedPointIndex =\n      draggingElementPointIndex ??\n      LinearElementEditor.getPointIndexUnderCursor(\n        element,\n        appState.zoom,\n        scenePointerX,\n        scenePointerY,\n      );\n\n    draggingElementPointIndex = draggingElementPointIndex ?? clickedPointIndex;\n    if (draggingElementPointIndex > -1) {\n      if (\n        editingLinearElement.draggingElementPointIndex !==\n          draggingElementPointIndex ||\n        editingLinearElement.activePointIndex !== clickedPointIndex\n      ) {\n        setState({\n          editingLinearElement: {\n            ...editingLinearElement,\n            draggingElementPointIndex,\n            activePointIndex: clickedPointIndex,\n          },\n        });\n      }\n\n      const [deltaX, deltaY] = rotate(\n        scenePointerX - lastX,\n        scenePointerY - lastY,\n        0,\n        0,\n        -element.angle,\n      );\n      const targetPoint = element.points[clickedPointIndex];\n      LinearElementEditor.movePoint(element, clickedPointIndex, [\n        targetPoint[0] + deltaX,\n        targetPoint[1] + deltaY,\n      ]);\n      return true;\n    }\n    return false;\n  }\n\n  static handlePointerUp(\n    editingLinearElement: LinearElementEditor,\n  ): LinearElementEditor {\n    const { elementId, draggingElementPointIndex } = editingLinearElement;\n    const element = LinearElementEditor.getElement(elementId);\n    if (!element) {\n      return editingLinearElement;\n    }\n\n    if (\n      draggingElementPointIndex !== null &&\n      (draggingElementPointIndex === 0 ||\n        draggingElementPointIndex === element.points.length - 1) &&\n      isPathALoop(element.points)\n    ) {\n      LinearElementEditor.movePoint(\n        element,\n        draggingElementPointIndex,\n        draggingElementPointIndex === 0\n          ? element.points[element.points.length - 1]\n          : element.points[0],\n      );\n    }\n    if (draggingElementPointIndex !== null) {\n      return {\n        ...editingLinearElement,\n        draggingElementPointIndex: null,\n      };\n    }\n    return editingLinearElement;\n  }\n\n  static handlePointerDown(\n    event: React.PointerEvent<HTMLCanvasElement>,\n    appState: AppState,\n    setState: React.Component<any, AppState>[\"setState\"],\n    history: SceneHistory,\n    scenePointerX: number,\n    scenePointerY: number,\n  ): {\n    didAddPoint: boolean;\n    hitElement: ExcalidrawElement | null;\n  } {\n    const ret: ReturnType<typeof LinearElementEditor[\"handlePointerDown\"]> = {\n      didAddPoint: false,\n      hitElement: null,\n    };\n\n    if (!appState.editingLinearElement) {\n      return ret;\n    }\n\n    const { elementId } = appState.editingLinearElement;\n    const element = LinearElementEditor.getElement(elementId);\n\n    if (!element) {\n      return ret;\n    }\n\n    if (event.altKey) {\n      if (!appState.editingLinearElement.lastUncommittedPoint) {\n        mutateElement(element, {\n          points: [\n            ...element.points,\n            LinearElementEditor.createPointAt(\n              element,\n              scenePointerX,\n              scenePointerY,\n            ),\n          ],\n        });\n      }\n      history.resumeRecording();\n      setState({\n        editingLinearElement: {\n          ...appState.editingLinearElement,\n          activePointIndex: element.points.length - 1,\n          lastUncommittedPoint: null,\n        },\n      });\n      ret.didAddPoint = true;\n      return ret;\n    }\n\n    const clickedPointIndex = LinearElementEditor.getPointIndexUnderCursor(\n      element,\n      appState.zoom,\n      scenePointerX,\n      scenePointerY,\n    );\n\n    // if we clicked on a point, set the element as hitElement otherwise\n    //  it would get deselected if the point is outside the hitbox area\n    if (clickedPointIndex > -1) {\n      ret.hitElement = element;\n    }\n\n    setState({\n      editingLinearElement: {\n        ...appState.editingLinearElement,\n        activePointIndex: clickedPointIndex > -1 ? clickedPointIndex : null,\n      },\n    });\n    return ret;\n  }\n\n  static handlePointerMove(\n    event: React.PointerEvent<HTMLCanvasElement>,\n    scenePointerX: number,\n    scenePointerY: number,\n    editingLinearElement: LinearElementEditor,\n  ): LinearElementEditor {\n    const { elementId, lastUncommittedPoint } = editingLinearElement;\n    const element = LinearElementEditor.getElement(elementId);\n    if (!element) {\n      return editingLinearElement;\n    }\n\n    const { points } = element;\n    const lastPoint = points[points.length - 1];\n\n    if (!event.altKey) {\n      if (lastPoint === lastUncommittedPoint) {\n        LinearElementEditor.movePoint(element, points.length - 1, \"delete\");\n      }\n      return editingLinearElement;\n    }\n\n    const newPoint = LinearElementEditor.createPointAt(\n      element,\n      scenePointerX,\n      scenePointerY,\n    );\n\n    if (lastPoint === lastUncommittedPoint) {\n      LinearElementEditor.movePoint(\n        element,\n        element.points.length - 1,\n        newPoint,\n      );\n    } else {\n      LinearElementEditor.movePoint(element, \"new\", newPoint);\n    }\n\n    return {\n      ...editingLinearElement,\n      lastUncommittedPoint: element.points[element.points.length - 1],\n    };\n  }\n\n  static getPointsGlobalCoordinates(\n    element: NonDeleted<ExcalidrawLinearElement>,\n  ) {\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n    const cx = (x1 + x2) / 2;\n    const cy = (y1 + y2) / 2;\n    return element.points.map((point) => {\n      let { x, y } = element;\n      [x, y] = rotate(x + point[0], y + point[1], cx, cy, element.angle);\n      return [x, y];\n    });\n  }\n\n  static getPointIndexUnderCursor(\n    element: NonDeleted<ExcalidrawLinearElement>,\n    zoom: AppState[\"zoom\"],\n    x: number,\n    y: number,\n  ) {\n    const pointHandles = this.getPointsGlobalCoordinates(element);\n    let idx = pointHandles.length;\n    // loop from right to left because points on the right are rendered over\n    //  points on the left, thus should take precedence when clicking, if they\n    //  overlap\n    while (--idx > -1) {\n      const point = pointHandles[idx];\n      if (\n        distance2d(x, y, point[0], point[1]) * zoom <\n        // +1px to account for outline stroke\n        this.POINT_HANDLE_SIZE / 2 + 1\n      ) {\n        return idx;\n      }\n    }\n    return -1;\n  }\n\n  static createPointAt(\n    element: NonDeleted<ExcalidrawLinearElement>,\n    scenePointerX: number,\n    scenePointerY: number,\n  ): Point {\n    const [x1, y1, x2, y2] = getElementAbsoluteCoords(element);\n    const cx = (x1 + x2) / 2;\n    const cy = (y1 + y2) / 2;\n    const [rotatedX, rotatedY] = rotate(\n      scenePointerX,\n      scenePointerY,\n      cx,\n      cy,\n      -element.angle,\n    );\n\n    return [rotatedX - element.x, rotatedY - element.y];\n  }\n\n  // element-mutating methods\n  // ---------------------------------------------------------------------------\n\n  /**\n   * Normalizes line points so that the start point is at [0,0]. This is\n   *  expected in various parts of the codebase.\n   */\n  static normalizePoints(element: NonDeleted<ExcalidrawLinearElement>) {\n    const { points } = element;\n\n    const offsetX = points[0][0];\n    const offsetY = points[0][1];\n\n    mutateElement(element, {\n      points: points.map((point, _idx) => {\n        return [point[0] - offsetX, point[1] - offsetY] as const;\n      }),\n      x: element.x + offsetX,\n      y: element.y + offsetY,\n    });\n  }\n\n  static movePoint(\n    element: NonDeleted<ExcalidrawLinearElement>,\n    pointIndex: number | \"new\",\n    targetPosition: Point | \"delete\",\n  ) {\n    const { points } = element;\n\n    // in case we're moving start point, instead of modifying its position\n    //  which would break the invariant of it being at [0,0], we move\n    //  all the other points in the opposite direction by delta to\n    //  offset it. We do the same with actual element.x/y position, so\n    //  this hacks are completely transparent to the user.\n    let offsetX = 0;\n    let offsetY = 0;\n\n    let nextPoints: (readonly [number, number])[];\n    if (targetPosition === \"delete\") {\n      // remove point\n      if (pointIndex === \"new\") {\n        throw new Error(\"invalid args in movePoint\");\n      }\n      nextPoints = points.slice();\n      nextPoints.splice(pointIndex, 1);\n      if (pointIndex === 0) {\n        // if deleting first point, make the next to be [0,0] and recalculate\n        //  positions of the rest with respect to it\n        offsetX = nextPoints[0][0];\n        offsetY = nextPoints[0][1];\n        nextPoints = nextPoints.map((point, idx) => {\n          if (idx === 0) {\n            return [0, 0];\n          }\n          return [point[0] - offsetX, point[1] - offsetY];\n        });\n      }\n    } else if (pointIndex === \"new\") {\n      nextPoints = [...points, targetPosition];\n    } else {\n      const deltaX = targetPosition[0] - points[pointIndex][0];\n      const deltaY = targetPosition[1] - points[pointIndex][1];\n      nextPoints = points.map((point, idx) => {\n        if (idx === pointIndex) {\n          if (idx === 0) {\n            offsetX = deltaX;\n            offsetY = deltaY;\n            return point;\n          }\n          offsetX = 0;\n          offsetY = 0;\n\n          return [point[0] + deltaX, point[1] + deltaY] as const;\n        }\n        return offsetX || offsetY\n          ? ([point[0] - offsetX, point[1] - offsetY] as const)\n          : point;\n      });\n    }\n\n    const nextCoords = getElementPointsCoords(element, nextPoints);\n    const prevCoords = getElementPointsCoords(element, points);\n    const nextCenterX = (nextCoords[0] + nextCoords[2]) / 2;\n    const nextCenterY = (nextCoords[1] + nextCoords[3]) / 2;\n    const prevCenterX = (prevCoords[0] + prevCoords[2]) / 2;\n    const prevCenterY = (prevCoords[1] + prevCoords[3]) / 2;\n    const dX = prevCenterX - nextCenterX;\n    const dY = prevCenterY - nextCenterY;\n    const rotated = rotate(offsetX, offsetY, dX, dY, element.angle);\n\n    mutateElement(element, {\n      points: nextPoints,\n      x: element.x + rotated[0],\n      y: element.y + rotated[1],\n    });\n  }\n}\n","import {\n  ExcalidrawElement,\n  NonDeletedExcalidrawElement,\n} from \"./element/types\";\nimport { getSelectedElements } from \"./scene\";\nimport { AppState } from \"./types\";\nimport { SVG_EXPORT_TAG } from \"./scene/export\";\nimport { tryParseSpreadsheet, renderSpreadsheet } from \"./charts\";\n\nlet CLIPBOARD = \"\";\nlet PREFER_APP_CLIPBOARD = false;\n\nexport const probablySupportsClipboardReadText =\n  \"clipboard\" in navigator && \"readText\" in navigator.clipboard;\n\nexport const probablySupportsClipboardWriteText =\n  \"clipboard\" in navigator && \"writeText\" in navigator.clipboard;\n\nexport const probablySupportsClipboardBlob =\n  \"clipboard\" in navigator &&\n  \"write\" in navigator.clipboard &&\n  \"ClipboardItem\" in window &&\n  \"toBlob\" in HTMLCanvasElement.prototype;\n\nexport const copyToAppClipboard = async (\n  elements: readonly NonDeletedExcalidrawElement[],\n  appState: AppState,\n) => {\n  CLIPBOARD = JSON.stringify(getSelectedElements(elements, appState));\n  try {\n    // when copying to in-app clipboard, clear system clipboard so that if\n    //  system clip contains text on paste we know it was copied *after* user\n    //  copied elements, and thus we should prefer the text content.\n    await copyTextToSystemClipboard(null);\n    PREFER_APP_CLIPBOARD = false;\n  } catch {\n    // if clearing system clipboard didn't work, we should prefer in-app\n    //  clipboard even if there's text in system clipboard on paste, because\n    //  we can't be sure of the order of copy operations\n    PREFER_APP_CLIPBOARD = true;\n  }\n};\n\nexport const getAppClipboard = (): {\n  elements?: readonly ExcalidrawElement[];\n} => {\n  if (!CLIPBOARD) {\n    return {};\n  }\n\n  try {\n    const clipboardElements = JSON.parse(CLIPBOARD);\n\n    if (\n      Array.isArray(clipboardElements) &&\n      clipboardElements.length > 0 &&\n      clipboardElements[0].type // need to implement a better check here...\n    ) {\n      return { elements: clipboardElements };\n    }\n  } catch (error) {\n    console.error(error);\n  }\n\n  return {};\n};\n\nexport const getClipboardContent = async (\n  appState: AppState,\n  cursorX: number,\n  cursorY: number,\n  event: ClipboardEvent | null,\n): Promise<{\n  text?: string;\n  elements?: readonly ExcalidrawElement[];\n  error?: string;\n}> => {\n  try {\n    const text = event\n      ? event.clipboardData?.getData(\"text/plain\").trim()\n      : probablySupportsClipboardReadText &&\n        (await navigator.clipboard.readText());\n\n    if (text && !PREFER_APP_CLIPBOARD && !text.includes(SVG_EXPORT_TAG)) {\n      const result = tryParseSpreadsheet(text);\n      if (result.type === \"spreadsheet\") {\n        return {\n          elements: renderSpreadsheet(\n            appState,\n            result.spreadsheet,\n            cursorX,\n            cursorY,\n          ),\n        };\n      } else if (result.type === \"malformed spreadsheet\") {\n        return { error: result.error };\n      }\n      return { text };\n    }\n  } catch (error) {\n    console.error(error);\n  }\n\n  return getAppClipboard();\n};\n\nexport const copyCanvasToClipboardAsPng = async (canvas: HTMLCanvasElement) =>\n  new Promise((resolve, reject) => {\n    try {\n      canvas.toBlob(async (blob: any) => {\n        try {\n          await navigator.clipboard.write([\n            new window.ClipboardItem({ \"image/png\": blob }),\n          ]);\n          resolve();\n        } catch (error) {\n          reject(error);\n        }\n      });\n    } catch (error) {\n      reject(error);\n    }\n  });\n\nexport const copyCanvasToClipboardAsSvg = async (svgroot: SVGSVGElement) => {\n  try {\n    await navigator.clipboard.writeText(svgroot.outerHTML);\n  } catch (error) {\n    console.error(error);\n  }\n};\n\nexport const copyTextToSystemClipboard = async (text: string | null) => {\n  let copied = false;\n  if (probablySupportsClipboardWriteText) {\n    try {\n      // NOTE: doesn't work on FF on non-HTTPS domains, or when document\n      //  not focused\n      await navigator.clipboard.writeText(text || \"\");\n      copied = true;\n    } catch (error) {\n      console.error(error);\n    }\n  }\n\n  // Note that execCommand doesn't allow copying empty strings, so if we're\n  //  clearing clipboard using this API, we must copy at least an empty char\n  if (!copied && !copyTextViaExecCommand(text || \" \")) {\n    throw new Error(\"couldn't copy\");\n  }\n};\n\n// adapted from https://github.com/zenorocha/clipboard.js/blob/ce79f170aa655c408b6aab33c9472e8e4fa52e19/src/clipboard-action.js#L48\nconst copyTextViaExecCommand = (text: string) => {\n  const isRTL = document.documentElement.getAttribute(\"dir\") === \"rtl\";\n\n  const textarea = document.createElement(\"textarea\");\n\n  textarea.style.border = \"0\";\n  textarea.style.padding = \"0\";\n  textarea.style.margin = \"0\";\n  textarea.style.position = \"absolute\";\n  textarea.style[isRTL ? \"right\" : \"left\"] = \"-9999px\";\n  const yPosition = window.pageYOffset || document.documentElement.scrollTop;\n  textarea.style.top = `${yPosition}px`;\n  // Prevent zooming on iOS\n  textarea.style.fontSize = \"12pt\";\n\n  textarea.setAttribute(\"readonly\", \"\");\n  textarea.value = text;\n\n  document.body.appendChild(textarea);\n\n  let success = false;\n\n  try {\n    textarea.select();\n    textarea.setSelectionRange(0, textarea.value.length);\n\n    success = document.execCommand(\"copy\");\n  } catch (error) {\n    console.error(error);\n  }\n\n  textarea.remove();\n\n  return success;\n};\n","import {\n  ExcalidrawElement,\n  NonDeletedExcalidrawElement,\n} from \"../element/types\";\n\nimport { getDefaultAppState } from \"../appState\";\n\nimport { AppState } from \"../types\";\nimport { exportToCanvas, exportToSvg } from \"../scene/export\";\nimport { fileSave } from \"browser-nativefs\";\n\nimport { t } from \"../i18n\";\nimport {\n  copyCanvasToClipboardAsPng,\n  copyCanvasToClipboardAsSvg,\n} from \"../clipboard\";\nimport { serializeAsJSON } from \"./json\";\n\nimport { ExportType } from \"../scene/types\";\nimport { restore } from \"./restore\";\nimport { restoreFromLocalStorage } from \"./localStorage\";\n\nexport { loadFromBlob } from \"./blob\";\nexport { saveAsJSON, loadFromJSON } from \"./json\";\nexport { saveToLocalStorage } from \"./localStorage\";\n\nconst BACKEND_GET = process.env.REACT_APP_BACKEND_V1_GET_URL;\n\nconst BACKEND_V2_POST = process.env.REACT_APP_BACKEND_V2_POST_URL;\nconst BACKEND_V2_GET = process.env.REACT_APP_BACKEND_V2_GET_URL;\n\nexport const SOCKET_SERVER = process.env.REACT_APP_SOCKET_SERVER_URL;\n\nexport type EncryptedData = {\n  data: ArrayBuffer;\n  iv: Uint8Array;\n};\n\nexport type SocketUpdateDataSource = {\n  SCENE_INIT: {\n    type: \"SCENE_INIT\";\n    payload: {\n      elements: readonly ExcalidrawElement[];\n    };\n  };\n  SCENE_UPDATE: {\n    type: \"SCENE_UPDATE\";\n    payload: {\n      elements: readonly ExcalidrawElement[];\n    };\n  };\n  MOUSE_LOCATION: {\n    type: \"MOUSE_LOCATION\";\n    payload: {\n      socketID: string;\n      pointerCoords: { x: number; y: number };\n      button: \"down\" | \"up\";\n      selectedElementIds: AppState[\"selectedElementIds\"];\n      username: string;\n    };\n  };\n};\n\nexport type SocketUpdateDataIncoming =\n  | SocketUpdateDataSource[keyof SocketUpdateDataSource]\n  | {\n      type: \"INVALID_RESPONSE\";\n    };\n\n// TODO: Defined globally, since file handles aren't yet serializable.\n// Once `FileSystemFileHandle` can be serialized, make this\n// part of `AppState`.\n(window as any).handle = null;\n\nconst byteToHex = (byte: number): string => `0${byte.toString(16)}`.slice(-2);\n\nconst generateRandomID = async () => {\n  const arr = new Uint8Array(10);\n  window.crypto.getRandomValues(arr);\n  return Array.from(arr, byteToHex).join(\"\");\n};\n\nconst generateEncryptionKey = async () => {\n  const key = await window.crypto.subtle.generateKey(\n    {\n      name: \"AES-GCM\",\n      length: 128,\n    },\n    true, // extractable\n    [\"encrypt\", \"decrypt\"],\n  );\n  return (await window.crypto.subtle.exportKey(\"jwk\", key)).k;\n};\n\nconst createIV = () => {\n  const arr = new Uint8Array(12);\n  return window.crypto.getRandomValues(arr);\n};\n\nexport const getCollaborationLinkData = (link: string) => {\n  if (link.length === 0) {\n    return;\n  }\n  const hash = new URL(link).hash;\n  return hash.match(/^#room=([a-zA-Z0-9_-]+),([a-zA-Z0-9_-]+)$/);\n};\n\nexport const generateCollaborationLink = async () => {\n  const id = await generateRandomID();\n  const key = await generateEncryptionKey();\n  return `${window.location.origin}${window.location.pathname}#room=${id},${key}`;\n};\n\nconst getImportedKey = (key: string, usage: KeyUsage) =>\n  window.crypto.subtle.importKey(\n    \"jwk\",\n    {\n      alg: \"A128GCM\",\n      ext: true,\n      k: key,\n      key_ops: [\"encrypt\", \"decrypt\"],\n      kty: \"oct\",\n    },\n    {\n      name: \"AES-GCM\",\n      length: 128,\n    },\n    false, // extractable\n    [usage],\n  );\n\nexport const encryptAESGEM = async (\n  data: Uint8Array,\n  key: string,\n): Promise<EncryptedData> => {\n  const importedKey = await getImportedKey(key, \"encrypt\");\n  const iv = createIV();\n  return {\n    data: await window.crypto.subtle.encrypt(\n      {\n        name: \"AES-GCM\",\n        iv,\n      },\n      importedKey,\n      data,\n    ),\n    iv,\n  };\n};\n\nexport const decryptAESGEM = async (\n  data: ArrayBuffer,\n  key: string,\n  iv: Uint8Array,\n): Promise<SocketUpdateDataIncoming> => {\n  try {\n    const importedKey = await getImportedKey(key, \"decrypt\");\n    const decrypted = await window.crypto.subtle.decrypt(\n      {\n        name: \"AES-GCM\",\n        iv: iv,\n      },\n      importedKey,\n      data,\n    );\n\n    const decodedData = new TextDecoder(\"utf-8\").decode(\n      new Uint8Array(decrypted) as any,\n    );\n    return JSON.parse(decodedData);\n  } catch (error) {\n    window.alert(t(\"alerts.decryptFailed\"));\n    console.error(error);\n  }\n  return {\n    type: \"INVALID_RESPONSE\",\n  };\n};\n\nexport const exportToBackend = async (\n  elements: readonly ExcalidrawElement[],\n  appState: AppState,\n) => {\n  const json = serializeAsJSON(elements, appState);\n  const encoded = new TextEncoder().encode(json);\n\n  const key = await window.crypto.subtle.generateKey(\n    {\n      name: \"AES-GCM\",\n      length: 128,\n    },\n    true, // extractable\n    [\"encrypt\", \"decrypt\"],\n  );\n  // The iv is set to 0. We are never going to reuse the same key so we don't\n  // need to have an iv. (I hope that's correct...)\n  const iv = new Uint8Array(12);\n  // We use symmetric encryption. AES-GCM is the recommended algorithm and\n  // includes checks that the ciphertext has not been modified by an attacker.\n  const encrypted = await window.crypto.subtle.encrypt(\n    {\n      name: \"AES-GCM\",\n      iv: iv,\n    },\n    key,\n    encoded,\n  );\n  // We use jwk encoding to be able to extract just the base64 encoded key.\n  // We will hardcode the rest of the attributes when importing back the key.\n  const exportedKey = await window.crypto.subtle.exportKey(\"jwk\", key);\n\n  try {\n    const response = await fetch(BACKEND_V2_POST, {\n      method: \"POST\",\n      body: encrypted,\n    });\n    const json = await response.json();\n    if (json.id) {\n      const url = new URL(window.location.href);\n      // We need to store the key (and less importantly the id) as hash instead\n      // of queryParam in order to never send it to the server\n      url.hash = `json=${json.id},${exportedKey.k!}`;\n      const urlString = url.toString();\n\n      window.prompt(`🔒${t(\"alerts.uploadedSecurly\")}`, urlString);\n    } else {\n      window.alert(t(\"alerts.couldNotCreateShareableLink\"));\n    }\n  } catch (error) {\n    console.error(error);\n    window.alert(t(\"alerts.couldNotCreateShareableLink\"));\n  }\n};\n\nexport const importFromBackend = async (\n  id: string | null,\n  privateKey: string | undefined,\n) => {\n  let elements: readonly ExcalidrawElement[] = [];\n  let appState: AppState = getDefaultAppState();\n\n  try {\n    const response = await fetch(\n      privateKey ? `${BACKEND_V2_GET}${id}` : `${BACKEND_GET}${id}.json`,\n    );\n    if (!response.ok) {\n      window.alert(t(\"alerts.importBackendFailed\"));\n      return restore(elements, appState, { scrollToContent: true });\n    }\n    let data;\n    if (privateKey) {\n      const buffer = await response.arrayBuffer();\n      const key = await getImportedKey(privateKey, \"decrypt\");\n      const iv = new Uint8Array(12);\n      const decrypted = await window.crypto.subtle.decrypt(\n        {\n          name: \"AES-GCM\",\n          iv: iv,\n        },\n        key,\n        buffer,\n      );\n      // We need to convert the decrypted array buffer to a string\n      const string = new window.TextDecoder(\"utf-8\").decode(\n        new Uint8Array(decrypted) as any,\n      );\n      data = JSON.parse(string);\n    } else {\n      // Legacy format\n      data = await response.json();\n    }\n\n    elements = data.elements || elements;\n    appState = { ...appState, ...data.appState };\n  } catch (error) {\n    window.alert(t(\"alerts.importBackendFailed\"));\n    console.error(error);\n  } finally {\n    return restore(elements, appState, { scrollToContent: true });\n  }\n};\n\nexport const exportCanvas = async (\n  type: ExportType,\n  elements: readonly NonDeletedExcalidrawElement[],\n  appState: AppState,\n  canvas: HTMLCanvasElement,\n  {\n    exportBackground,\n    exportPadding = 10,\n    viewBackgroundColor,\n    name,\n    scale = 1,\n    shouldAddWatermark,\n  }: {\n    exportBackground: boolean;\n    exportPadding?: number;\n    viewBackgroundColor: string;\n    name: string;\n    scale?: number;\n    shouldAddWatermark: boolean;\n  },\n) => {\n  if (elements.length === 0) {\n    return window.alert(t(\"alerts.cannotExportEmptyCanvas\"));\n  }\n  if (type === \"svg\" || type === \"clipboard-svg\") {\n    const tempSvg = exportToSvg(elements, {\n      exportBackground,\n      viewBackgroundColor,\n      exportPadding,\n      shouldAddWatermark,\n    });\n    if (type === \"svg\") {\n      await fileSave(new Blob([tempSvg.outerHTML], { type: \"image/svg+xml\" }), {\n        fileName: `${name}.svg`,\n      });\n      return;\n    } else if (type === \"clipboard-svg\") {\n      copyCanvasToClipboardAsSvg(tempSvg);\n      return;\n    }\n  }\n\n  const tempCanvas = exportToCanvas(elements, appState, {\n    exportBackground,\n    viewBackgroundColor,\n    exportPadding,\n    scale,\n    shouldAddWatermark,\n  });\n  tempCanvas.style.display = \"none\";\n  document.body.appendChild(tempCanvas);\n\n  if (type === \"png\") {\n    const fileName = `${name}.png`;\n    tempCanvas.toBlob(async (blob: any) => {\n      if (blob) {\n        await fileSave(blob, {\n          fileName: fileName,\n        });\n      }\n    });\n  } else if (type === \"clipboard\") {\n    try {\n      copyCanvasToClipboardAsPng(tempCanvas);\n    } catch {\n      window.alert(t(\"alerts.couldNotCopyToClipboard\"));\n    }\n  } else if (type === \"backend\") {\n    const appState = getDefaultAppState();\n    if (exportBackground) {\n      appState.viewBackgroundColor = viewBackgroundColor;\n    }\n    exportToBackend(elements, appState);\n  }\n\n  // clean up the DOM\n  if (tempCanvas !== canvas) {\n    tempCanvas.remove();\n  }\n};\n\nexport const loadScene = async (id: string | null, privateKey?: string) => {\n  let data;\n  if (id != null) {\n    // the private key is used to decrypt the content from the server, take\n    // extra care not to leak it\n    data = await importFromBackend(id, privateKey);\n    window.history.replaceState({}, \"Excalidraw\", window.location.origin);\n  } else {\n    data = restoreFromLocalStorage();\n  }\n\n  return {\n    elements: data.elements,\n    appState: data.appState && { ...data.appState },\n    commitToHistory: false,\n  };\n};\n","import React from \"react\";\n\nimport \"./App.css\";\nimport Toolbar from \"./Toolbar\";\nimport Viewer from \"./Viewer\";\nimport { useLoadElements } from \"./useLoadElements\";\n\nconst App: React.FC = () => {\n  const { loading, elements, loadData } = useLoadElements();\n  if (loading) {\n    return <div>Loading...</div>;\n  }\n  return (\n    <div className=\"App\">\n      {elements && <Viewer elements={elements} />}\n      <Toolbar elements={elements} loadData={loadData} />\n    </div>\n  );\n};\n\nexport default App;\n","import { useCallback, useEffect, useState } from \"react\";\n\nimport { importFromBackend } from \"./excalidraw/src/data\";\nimport { getNonDeletedElements } from \"./excalidraw/src/element\";\nimport {\n  ExcalidrawElement,\n  NonDeletedExcalidrawElement,\n} from \"./excalidraw/src/element/types\";\n\nexport const useLoadElements = () => {\n  const [loading, setLoading] = useState(true);\n  const [elements, setElements] = useState<\n    readonly NonDeletedExcalidrawElement[]\n  >();\n\n  const loadData = useCallback(\n    (data: { elements: readonly ExcalidrawElement[] }) => {\n      setElements(getNonDeletedElements(data.elements));\n    },\n    []\n  );\n\n  useEffect(() => {\n    (async () => {\n      const hash = window.location.hash.slice(1);\n      const searchParams = new URLSearchParams(hash);\n      const match = /([0-9]+),?([a-zA-Z0-9_-]*)/.exec(\n        searchParams.get(\"json\") || \"\"\n      );\n      if (match) {\n        const [, id, key] = match;\n        const data = await importFromBackend(id, key);\n        loadData(data);\n      }\n      setLoading(false);\n    })();\n  }, [loadData]);\n\n  return { loading, elements, loadData };\n};\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === \"localhost\" ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === \"[::1]\" ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === \"production\" && \"serviceWorker\" in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener(\"load\", () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            \"This web app is being served cache-first by a service \" +\n              \"worker. To learn more, visit https://bit.ly/CRA-PWA\"\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === \"installed\") {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                \"New content is available and will be used when all \" +\n                  \"tabs for this page are closed. See https://bit.ly/CRA-PWA.\"\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log(\"Content is cached for offline use.\");\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch((error) => {\n      console.error(\"Error during service worker registration:\", error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { \"Service-Worker\": \"script\" },\n  })\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get(\"content-type\");\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf(\"javascript\") === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        \"No internet connection found. App is running in offline mode.\"\n      );\n    });\n}\n\nexport function unregister() {\n  if (\"serviceWorker\" in navigator) {\n    navigator.serviceWorker.ready\n      .then((registration) => {\n        registration.unregister();\n      })\n      .catch((error) => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}